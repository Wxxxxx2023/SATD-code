Hib,positive,this is only needed afaict for processing results from the query cache however this cannot possibly work in the case of discovered types
Hib,positive,note that this timestamp is not correct if the connection provider returns an older jdbc connection that was associated with a transaction that was already begun before opensession was called do not know any possible solution to this
Hib,positive,todo this is assertion is disabled because there is a bug that means the original owner of a transient uninitialized collection is not known if the collection is re referenced by a different object associated with the current session throw new assertionfailure bug loading unowned collection
Hib,positive,this does not support the cache sql  distinct by comma list   extensions but this extension is not supported through hibernate anyway
Hib,positive,todo when this is the entry point we should use an inner join for fetching the many to many elements
Hib,positive,could happen for custom criteria impls not likely but for long term solution see hhh 
Hib,positive,todo currently broken for unique key references does not detect change to unique key property of the associated object the owner of the association is not the owner of the id
Hib,positive,todo currently broken for unique key references does not detect change to unique key property of the associated object
Hib,positive,todo entities can be compared by pk and entity name fix this
Hib,positive,todo does not work for entitymode dom j yet
Hib,positive,todo deal with the optional attribute in the join mapping this code assumes that optional defaults to true because it does not actually seem to work in the fetch join code note that actual proper handling of optional ality here is actually more involved than this patch assumes remember that we might have multiple join mappings associated with a single entity really a couple of things need to happen to properly handle optional here first and foremost when handling multiple join s we really should be using the entity root table as the driving table another option here would be to choose some non optional joined table to use as the driving table in all likelihood just using the root table is much simplier need to add the fk columns corresponding to each joined table to the generated select list these would then be used when iterating the result set to determine whether all non optional data is present my initial thoughts on the best way to deal with this would be to introduce a new sequentialselect abstraction that actually gets generated in the persisters ok singletable and utilized here it would encapsulated all this required optional ality checking
Hib,positive,todo would be nice to use false but issues with ms sql
Hib,positive,todo not really completely correct since the uoe could occur while resolving associations leaving the pc in an inconsistent state
Hib,positive,todo this is kinda inconsistent with collectiontype
Hib,positive,for a one to many a bag is not really a bag it is really a set since it ca not contain the same element twice it could be considered a bug in the mapping dtd that bag allows one to many
Hib,positive,todo entities can be compared by pk fix this only if when we can extract the id values
Hib,positive,todo old version did not require hashmap lookup keys collectionowner getidentifier
Hib,positive,todo this disables laziness even in non pojo entity modes
Hib,positive,todo at the point where we are resolving collection references we do not know if the uk value has been resolved depends if it was earlier or later in the mapping document now we could try and use e getstatus to decide to semiresolve trouble is that initializeentity reuses the same array for resolved and hydrated values
Hib,positive,todo currently we do not know a sessionfactory reference when building the tuplizer this is a bug embedded xml false on component todo fix this after hhh is complete
Hib,positive,todo this requires that the collection is defined after the referenced property in the mapping file ok ?
Hib,positive,todo currently we really do not handle valueinclusion partial valueinclusion partial would indicate parts of a component need to be included in the select currently we then just render the entire component into the select clause in that case
Hib,positive,todo is this completely correct ?
Hib,positive,todo what if batchupdate is a callablestatement ? calls executebatch
Hib,positive,this does not actually seem to work but it might work on some dbs also it does not work if there are multiple columns of results because it is not accounting for the suffix return new string getdiscriminatorcolumnname
Hib,positive,first validate all the enabled filters todo this implementation has bad performance
Hib,positive,todo passing null here because this method is not really used for dom j at the moment but it is still a bug if we do not get rid of this
Hib,positive,todo this really needs to be delayed unitl after we definitively know the operand node type where this is currently a problem is parameters for which where we cannot unequivocally resolve an expected type
Hib,positive,algorithm check for any level one nullability breaks look at non null components to recursively check next level of nullability breaks look at collections contraining component to recursively check next level of nullability breaks in the previous implementation not null stuffs where checked filtering by level one only updateable or insertable columns so setting a sub component as update false has no effect on not null check if the main component had good checkeability in this implementation we keep this feature however i never see any documentation mentioning that but it is for sure a limitation
Hib,positive,assume that the row was not there since it previously had only null values so do an insert instead todo does not respect dynamic insert
Hib,positive,todo this call will not work for anything other than pojos
Hib,positive,note that this implementation is kinda broken for components with many to one associations
Hib,positive,no need to take a snapshot this is a performance optimization but not really important except for entities with huge mutable property values
Hib,positive,todo this is broke for subqueries in statements other than selects
Hib,positive,the following types are not supported in rdms jdbc and therefore commented out however in some cases mapping them to character columns works for many applications but does not work for all cases
Hib,positive,todo should this be an error ?
Hib,positive,three general cases we check here as to whether to render a physical sql join is our parent a dotnode as well ? if so our property reference is being further de referenced is this a dml statement we were asked to generate any needed joins generatejoins true or we are currently processing a select or from clause an additional check is the regression style join suppression check solely intended for the test suite the regression style join suppression is an additional check intended solely for use within the test suite this forces the implicit join resolution to behave more like the classic parser the underlying issue is that classic translator is simply wrong about its decisions on whether or not to render an implicit join into a physical sql join in a lot of cases the piece it generally tends to miss is that inner joins effect the results by further restricting the data set a particular manifestation of this is the fact that the classic translator will skip the physical join for toone implicit joins if the query is shallow the result being that query list and query iterate could return different number of results
Hib,positive,todo figure out how this should be set this was the reason for failures regarding index op and subclass joins on theta join dialects not sure what behaviour we were trying to emulate joinsequence joinsequence getfrompart emulate the old addfromonly behavior
Hib,positive,the preference here would be sqlfunctiontemplate hibernate timestamp current timestamp ? false but this appears not to work jay nance 
Hib,positive,todo would be nice to use false but issues with ms sql
Hib,positive,todo inexact what we really need to know is are any outer joins used ?
Hib,positive,todo would be nice to use false but issues with ms sql
Hib,positive,todo not sure which either ? is correct could not find docs on how to do this did find various blogs and forums mentioning that select current timestamp does not work
Hib,positive,todo cannot use generatesuffixes it handles the initial suffix differently
Hib,positive,do not need this because we should never ever be selecting no columns in an insert select and because it causes a bug on db 
Hib,positive,starts with an alias old style semi bad thing about this ca not re alias another alias
Hib,positive,todo bug this currently fails for named queries for non pojo entities
Hib,positive,fixme we do not have the associated entity table name here has to be done in a second pass
Hib,positive,this call is side effecty
Hib,positive,rdms does not directly support the trim function we use rtrim and ltrim
Hib,positive,note at least my local sql server express shows this not working
Hib,positive,note at least my local mysql install shows this not working
Hib,positive,use count as the default this mimics the old behavior although none might be a better option moving forward in the case of callable
Hib,positive,perhaps not really necessary
Hib,positive,todo what else to do here ?
Hib,positive,todo disable batch loading if lockmode read ?
Hib,positive,todo what else to do here ?
Hib,positive,todo to handle concurrent writes correctly the client should pass in a lock
Hib,positive,turn hibernate c p into c p so c p gets a chance to see all hibernate c p 
Hib,positive,note there is a wierd implementation in the client side
Hib,positive,todo this was added to support initializing an entity is entityentry snapshot during reattach this should be refactored to instead expose a method to assemble a entityentry based on this state for return
Hib,positive,do we need to drop constraints before dropping tables in this dialect ?
Hib,positive,fixme per the regionfactory class javadoc this constructor version should not be necessary param props the configuration properties
Hib,positive,does this dialect support check constraints ?
Hib,positive,this is called by sessionfactory irregardless we just disregard here could also add a check to sessionfactory to only conditionally call start
Hib,positive,does this dialect support the unique column syntax ?
Hib,positive,this is done here  cos we might only know the type here ugly todo improve this a lot
Hib,positive,does this dialect support the for update syntax ?
Hib,positive,todo what is the implication of this ?
Hib,positive,todo yuck
Hib,positive,todo again how should this work for non pojo entities ?
Hib,positive,does this dialect support for update of allowing particular rows to be locked ?
Hib,positive,todo really bad evil hack to fix
Hib,positive,aliasrefnode resolve false false aliasrefnode gettext todo is it kosher to do it here ? todo is it kosher to do it here ?
Hib,positive,todo better to degrade to lazy false if uninstrumented
Hib,positive,does this dialect support the oracle style for update nowait syntax ?
Hib,positive,fixme per the regionfactory class javadoc this constructor version should not be necessary param props the configuration properties
Hib,positive,icky workaround for mysql bug
Hib,positive,we have to set up the table later yuck
Hib,positive,todo somehow add the newly created foreign keys to the internal collection
Hib,positive,this inner class implements a case statement perhaps im being a bit over clever here
Hib,positive,todo merge into one method
Hib,positive,todo this is a bit of copy paste from indexedcollection createprimarykey
Hib,positive,todo what type ?
Hib,positive,todo inefficient
Hib,positive,fixme get the persistentclass
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,todo this is too conservative if all preceding joins were also inner joins we could use an inner join here
Hib,positive,todo redesign how propertyaccessors are acquired
Hib,positive,todo not so sure this is needed
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,create an index on the key columns ? ?
Hib,positive,todo joinkeycolumnname foreignkeycolumnname should be called either here or at a slightly higer level in the stack to get all the information we need right now hbmbinder does not support the
Hib,positive,todo improve this hack
Hib,positive,todo bad implementation cos it depends upon ordering of mapping doc fixing this requires that collection persistentclass gain access to the mappings reference from configuration or the filterdefinitions map directly sometime during configuration buildsessionfactory after all the types filter defs are known and before building persisters
Hib,positive,use of trim here is ugly ?
Hib,positive,todo ideally we need the construction of propertyaccessor to take the following entitymode entitymode specific data i e the classname for pojo entities property specific data based on the entitymode i e property name or dom j node name the easiest way with the introduction of the new runtime metamodel classes would be the the following predicates propertyaccessorfactory getpropertyaccessor takes references to both a org hibernate metadata entitymodemetadata and org hibernate metadata property what is now termed a propertyaccessor stores any values needed from those two pieces of information code can then simply call propertyaccess getgetter with no parameters likewise with propertyaccessor getsetter
Hib,positive,can happen because of the multiple ways cache remove can be invoked
Hib,positive,ick
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,todo this is very suboptimal for some subclasses namely components since it does not take advantage of two phase load
Hib,positive,todo should this be session instantiate persister ?
Hib,positive,todo suck this into initlaziness
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive, hibernate temp use jdbc metadata defaults  is a temporary magic value the need for it is intended to be alleviated with future developement thus it is not defined as an environment constant it is used to control whether we should consult the jdbc metadata to determine certain settings default values it is useful to not do this when the database may not be available mainly in tools usage
Hib,positive,todo is this right ? ?
Hib,positive,ie the subquery yuck
Hib,positive,use of a stringbuffer to workaround a jdk bug
Hib,positive,todo copy paste from recreate
Hib,positive,workaround for backward compatibility of sets with no not null columns assume all columns are used in the row locator sql
Hib,positive,todo this eventually needs to be removed
Hib,positive,todo remove
Hib,positive,just to help out during the load ugly i know
Hib,positive,hack workaround as sqlquery impl depend on having a key
Hib,positive,todo handle the case of a foreign key to something other than the pk
Hib,positive,todo assumes all collections disassemble to an array
Hib,positive,todo would love to have this work on a notification basis where the successful binding of an entity subclass would emit a notification which the extendsqueue entries could react to
Hib,positive,todo is it really neceassry to provide configuration to collectionpersisters ? should it not be enough with associated class ? or why does entitypersister is not get access to configuration ? the only reason i could see that configuration gets passed to collection persisters is so that they can look up the dom j node name of the entity element in case no explicit node name was applied at the collection element level are you kidding me ? trivial to fix then just store and expose the node name on the entity persister which the collection persister looks up anyway via other means
Hib,positive,todo deprecated remove eventually
Hib,positive,todo possibly relax that
Hib,positive,todo this is a bit dodgy come up with a better way to check this plus see above comment
Hib,positive,use a degenerated strategy for backward compatibility
Hib,positive,todo this is temporary in that the end result will probably not take a property reference per se
Hib,positive,todo better to handle dynamic filters through implicit dynamicfilterparameterspecification see the discussion there in dynamicfilterparameterspecification is javadocs as to why it is currently not done that way
Hib,positive,get the right object from the list would it be easier to just call getentity ? ?
Hib,positive,todo should record how many properties we have reffered to and if we do not get em all we throw an exception way better than trial and error
Hib,positive,todo this dependency is kinda bad
Hib,positive,todo get sql rendering out of this package
Hib,positive,why does this matter ?
Hib,positive,important to account for newly saved entities in query todo some kind of check for new status
Hib,positive,todo get sql rendering out of this package
Hib,positive,todo can we always use the null property approach for everything ?
Hib,positive,does this need holdlock also ? return tablename with updlock rowlock holdlock
Hib,positive,for sets we should end the collection load after resolving the entities since we might call hashcode on the elements todo or we could do this polymorphically and have two different operations implemented differently for arrays
Hib,positive,todo remove this and just have subclasses use isolater isolatedwork directly
Hib,positive,sql server at least needed this dropped after use strange
Hib,positive,is it necessary to register exact since it can only appear in a where clause ?
Hib,positive,for arrays we should end the collection load before resolving the entities since the actual array instances are not instantiated during loading todo or we could do this polymorphically and have two different operations implemented differently for arrays
Hib,positive,does this dialect support the alter table syntax ?
Hib,positive,this next bit is to allow for both unsaved value negative and for older behavior where version number did not get seeded if it was already set in the object todo shift it into unsaved value strategy
Hib,positive,todo reenable if we also fix the above todo
Hib,positive,orphans should not be deleted during copy ? ?
Hib,positive,orphans should not be deleted during merge ? ?
Hib,positive,todo suck this logic into the collection
Hib,positive,todo we can actually just determine this from the incoming entityentry s
Hib,positive,todo this bit actually has to be called after all cascades but since identity insert is called synchronously instead of asynchronously as other actions it is not
Hib,positive,this class has no proxies so do a shortcut
Hib,positive,todo should this be an initializeentityeventlistener ? ? ? watch out for performance
Hib,positive,todo need map ? the prob is a proper key right ?
Hib,positive,todo better to pass the id in as an argument ?
Hib,positive,do we even really need this ? the update will fail anyway
Hib,positive,todo would it be better to do a refresh from db ?
Hib,positive,this form used from annotations ? essentially the same as the above using a resultset mapping reference but without cachemode readonly and comment fixme annotations do not use it so it can be remove from my pov deprecated param query the sql query string param resultsetref the result set mapping name param queryspaces any specified query spaces used for auto flushing param cacheable whether the query results are cacheable param cacheregion if cacheable the region into which to store the results param timeout a jdbc level timeout to be applied param fetchsize a jdbc level fetch size to be applied param flushmode the flush mode to use for this query param parametertypes parameter type map param callable does the query string represent a callable object i e proc
Hib,positive,todo ugly here
Hib,positive,todo not quite sure about the full implications of this
Hib,positive,this only works because collection entries are kept in a sequenced map by persistence context maybe we should do like entities and keep a separate sequences set todo calling entryset on an identitymap is slow
Hib,positive,todo i  d much rather have this done from endloadingcollection collectionpersister loadingcollectionentry
Hib,positive,todo hack note here we cleanup the load context when we have no more local lce entries this works for the time being because really only the collection load contexts are implemented long term this cleanup should become part of the close result set processing from the sandbox jdbc jdbc container code
Hib,positive,todo add the notion of enabled filters to the cachekey to differentiate filtered collections from non filtered but cachekey is currently used for both collections and entities would ideally need to define two seperate ones currently this works in conjuction with the check on defaultinitializecollectioneventhandler initializecollectionfromcache which makes sure to not read from cache with enabled filters early exit
Hib,positive,postload is needed for ejb todo reuse the postloadevent
Hib,positive,todo should we check the current isolation mode explicitly ?
Hib,positive,brand new collection todo or an array we ca not lock objects with arrays now ? ?
Hib,positive,todo iteratively get transient entities and retry merge until one of the following conditions transientcopycache size transientcopycache size is not decreasing and copycache size is not increasing todo find out if retrying can add entities to copycache do not think it can for now just retry once throw transientobjectexception if there are still any transient entities
Hib,positive,null or brand new collection this will also inefficiently handle arrays which have no snapshot so we ca not do any better
Hib,positive,todo perhaps we should additionally require that the incoming entity version be equivalent to the defined unsaved value ?
Hib,positive,provides query splitting methods which were originally in querytranslator br todo this will need to be refactored at some point author josh
Hib,positive,todo most of below was taken verbatim from dotnode should either delegate this logic or super type it
Hib,positive,todo currently expects that the individual with expressions apply to the same sql table join this may not be the case for joined subclass where the property values might be coming from different tables in the joined hierarchy at some point we should expand this to support that capability however that has some difficulties the biggest is how to handle ors when the individual comparisons are linked to different sql joins here we would need to track each comparison individually along with the join alias to which it applies and then pass that information back to the fromelement so it can pass it along to the joinsequence
Hib,positive,no explicit select expression render the id and properties projection lists for every persister in the from clause into a single  token node  todo the only reason we need this stuff now is collection filters we should get rid of derived select clause completely
Hib,positive,todo better way ? ?
Hib,positive,hack alert attempt to work around ghost impliedfromelements that occasionally show up between the actual things being joined this consistently occurs from index nodes at least against many to many not sure if there are other conditions essentially look ahead to the next fromelement that actually writes something to the sql
Hib,positive,not possible to simply re use the versionpropertynode here as it causes oom errors due to circularity
Hib,positive,this function has a template restore output apply the template and write the result out todo downcast to avoid using an interface ? yuck
Hib,positive,at some point the generate phase needs to be moved out of here because a single object level dml might spawn multiple sql dml command executions possible to just move the sql generation for dml stuff but for consistency sake probably best to just move responsiblity for the generation phase completely into the delegates queryloader statementexecutor themselves also not sure why queryloader currently even has a dependency on this at all does it need it ? ideally like to see the walker itself given to the delegates directly
Hib,positive,todo this is only needed during compilation can we eliminate the instvar ?
Hib,positive,todo absolutely no usages of this constructor form can it go away ?
Hib,positive,todo is this a bit ugly ?
Hib,positive,even here if only properties mapped to the base table are referenced in the set and where clauses this could be handled by the basicdelegate todo decide if it is better performance wise to perform that check or to simply use the multitableupdatedelegate
Hib,positive,todo remove these last two as batcher is no longer managing connections
Hib,positive,very important this class needs to be free of any static references to any cglib or javassist classes otherwise users will always need both on their classpaths no matter which if either they use another option here would be to remove the hibernate ispropertyinitialized method and have the users go through the sessionfactory to get this information
Hib,positive,todo we really need to be able to deal with component paths here also this is difficult because the hql sql grammar expects all those node types to be fromreferencenodes one potential fix here would be to convert the intoclause to just use a fromclause fromelement combo as a child of the insertstatement and move all this logic into the insertstatement that is probably the easiest approach read least amount of changes to the grammar and code but just does not feel right as then an insert would contain from clauses
Hib,positive,todo an optimization here would be to consider cascade deletes and not gen those delete statements the difficulty is the ordering of the tables here vs the cascade attributes on the persisters the table info gotten here should really be self contained i e a class representation defining all the needed attributes then we could then get an array of those
Hib,positive,todo switch statements are always evil we already had bugs because of forgotten token types use polymorphism for this
Hib,positive,really there are two situations where it should be ok to allow the insertion into properties defined on a superclass union subclass with an abstract root entity discrim subclass is handled already because of the fact that unionsubclasspersister alreay always returns for this call we may want to disallow it for discrim subclass just for consistency sake currently does not work anyway
Hib,positive,implicit joins are always ? ok to reuse
Hib,positive,todo used to be exprnoparens was this needed ?
Hib,positive,todo we may also want to check that the types here map to exactly one column jdbc type ca not think of a situation where arithmetic expression between multi column mappings makes any sense
Hib,positive,we do not know either type blind guess
Hib,positive,todo get sql rendering out of here create an ast for the join expressions use the sql generator grammar to generate the sql text for the index expression
Hib,positive,we would probably refactor to have logicparser builds a tree of simple expressions connected by and or not expressionparser translates from oo terms like foo foo bar foo bar baz to sql terms like foos id foos bar id etc and pathexpressionparser which does much the same thing it does now
Hib,positive,short circuit for performance
Hib,positive,not absolutely necessary but does help with aggressive release
Hib,positive,try block is a hack around fact that currently tuplizers are not given the opportunity to resolve a subclass entity name this allows the we assume custom interceptor the ability to influence this decision if we were not able to based on the given entityname
Hib,positive,todo this is one of the ugliest and most fragile pieces of code in hibernate
Hib,positive,todo implement functionality this might be painful to do here as the join post processing for the subquery has already been performed meaning that for theta join dialects the join conditions have already been moved over to the where clause a simple solution here might to perform join post processing once for the entire query including any subqueries at one fell swoop
Hib,positive,yuck
Hib,positive,ignore it the incoming property could not be found so we cannot be sure what to do here at the very least the safest is to simply not apply any dereference toggling
Hib,positive,todo make this a bit nicer
Hib,positive,yuck
Hib,positive,todo potentially look at optimizing these two arrays
Hib,positive,note that i parameter is now unused delete it ?
Hib,positive,todo figure out a better way to get the from elements in a proper tree structure if this is not the destination of a many to many add it as a child of the origin
Hib,positive,todo this constructor form is only used from constructor directly below us can it go away ?
Hib,positive,todo remove
Hib,positive,we should reengineer this class so that rather than the current ad hoc linear approach to processing a stream of tokens we instead build up a tree of expressions
Hib,positive,todo should this get moved to persistentcontext ? logically is persistentcontext the thing to which an interceptor gets attached ?
Hib,positive,todo something much better look at the type of the other expression todo have comparisonexpression and or arithmeticexpression rules complete the resolution of boolean nodes
Hib,positive,todo this class does too many things we need a different kind of path expression parser for each of the diffferent ways in which path expressions can occur
Hib,positive,todo optimize this better
Hib,positive,todo should we allow suffixes on these ?
Hib,positive,todo is this really necessary ? ? ? ?
Hib,positive,todo not sure the best way to handle this the non performant way
Hib,positive,todo is there a better way ?
Hib,positive,the class is now way to complex
Hib,positive,todo would be really nice to cache the spec on the query def so as to not have to re calc the hash currently not doable though because of the resultset ref stuff
Hib,positive,name from a super query a bit inelegant that it shows up here
Hib,positive,real hacky used to count the nesting of parentheses
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,put has nowait semantics is this really appropriate ? note that it needs to be async replication never local or sync
Hib,positive,ugly hack for cases like elements foo bar collection multi part path expression ending in elements or indices
Hib,positive,fixme hacky workaround to jbcache 
Hib,positive,todo copy paste from sessionimpl pull up
Hib,positive,todo need to find a clean way to handle the event source role a seperate classs responsible for generating dispatching events just duplicates most of the session methods passing around seperate reto interceptor factory actionqueue and persistentcontext is not manageable
Hib,positive,must be done here because of side effect yuck
Hib,positive,we should actually rework this class to not implement parser and just process path expressions in the most convenient way
Hib,positive,todo should remove this exposure and have all references to the session is batcher use the connectionmanager
Hib,positive,we may be screwed here since the collection action is about to execute and we do not know the final owner key value
Hib,positive,needed the clazz check to work around union subclasses todo is there a way to tell whether a persister is truly discrim column based inheritence ?
Hib,positive,work around a bug in all known connection pools
Hib,positive,todo reuse the preloadevent
Hib,positive,need a better way to define the suffixes here
Hib,positive,workaround for weblogic
Hib,positive,todo temporary
Hib,positive,todo yuck fix after hhh is complete
Hib,positive,would be great to move all this below here into another method that could also be used from the new scrolling stuff would need to change the way the max row stuff is handled i e behind an interface so that i could do the control breaking at the means to know when to stop
Hib,positive,todo the i entityspan bit depends upon subclass implementation very bad
Hib,positive,some messy complex stuff here since createcriteria can take an aliased path or a path rooted at the creating criteria instance
Hib,positive,todo add a criteriaimplementor interface this class depends directly upon criteriaimpl in the impl package
Hib,positive,polymorphism not really handled completely correctly perhaps well actually its ok assuming that the entity name used in the lookup is the same as the the one used here which it will be
Hib,positive,this is not very nice and quite slow
Hib,positive,todo get sql rendering out of here
Hib,positive,meant to handle dynamic instantiation queries copy from queryloader
Hib,positive,make sure this is a defined parameter and check the incoming value type todo what should be the actual exception type here ?
Hib,positive,worrying about proxies is perhaps a little bit of overkill here
Hib,positive,todo throw exception ? maybe warn if not the same ?
Hib,positive,todo make entitypersister not depend on sessionfactoryimplementor interface if possible
Hib,positive,todo what amount of significant digits need to be supported here ? from the decimalformat docs significant digits minimum integer digits maximum fraction digits
Hib,positive,for backward compatibility allow a set with no not null element columns using all columns in the row locater sql todo create an implicit not null constraint on all cols ?
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,todo copy paste from manytoonetype
Hib,positive,todo code duplication with singletableentitypersister
Hib,positive,todo throw exception ?
Hib,positive,should this interface extend propertymapping ?
Hib,positive,todo here is why we need to make bytecode provider global todo again fix this after hhh is complete
Hib,positive,todo currently keeps getters and setters instead of propertyaccessors because of the way getgetter and getsetter are implemented currently yuck
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,todo yuck this is not quite good enough it is a quick hack around the problem of having a to one association that refers to an embedded component
Hib,positive,todo implement caching ? proxies ?
Hib,positive,is this really necessary ?
Hib,positive,todo this is a little inefficient do not need to do a whole deep replaceelements call
Hib,positive,todo this is a bit arbitrary expose a switch to the user ?
Hib,positive,return collection removal fixme even if isinverse true ?
Hib,positive,todo fix this so it will work for non pojo entity mode
Hib,positive,todo move these to a new joinabletype abstract class extended by entitytype and persistentcollectiontype
Hib,positive,todo would be nice to handle proxy classes elegantly
Hib,positive,spaces todo i m not sure but perhaps we should exclude abstract denormalized tables ?
Hib,positive,todo is there a more elegant way than downcasting ?
Hib,positive,todo remove
Hib,positive,todo remove use of instanceof
Hib,positive,create an index on the key columns ? ?
Hib,positive,todo make this a bit nicer
Hib,positive,todo we can remove this once the deprecated ctor can be made private
Hib,positive,todo perhaps this should be some other runtimeexception
Hib,positive,yuck
Hib,positive,todo need some caching scheme ? really comes down to decision regarding amount of state if any kept on propertyaccessors
Hib,positive,todo this eventually needs to be removed
Hib,positive,todo design new lifecycle for proxyfactory
Hib,positive,todo we should really just collect these from the various selectexpressions rather than regenerating here
Hib,positive,todo should this really return null ? if not figure out something better to do here
Hib,positive,todo should seriously consider not allowing a txn to begin from a child session can always route the request to the root session
Hib,positive,should indicate that we are processing an insert update delete query with a subquery implied via a collection property function here we need to use the table name itself as the qualification alias todo verify this works for all databases todo is this also the case in non indexed scenarios ?
Hib,positive,todo this really needs to be delayed unitl after we definitively know all node types where this is currently a problem is parameters for which where we cannot unequivocally resolve an expected type
Hib,positive,todo make this the factory for entity mode related sessions also means making this the target of transaction synch and the thing that knows how to cascade things between related sessions at that point perhaps this thing is a sessioncontext and connectionmanager is a jdbccontext ? a sessioncontext should live in the impl package
Hib,positive,create an index on the key columns ? ?
Hib,positive,is this ok ?
Hib,positive,init the table here instead of earlier so that we can get a quoted table name todo would it be better to simply pass the qualified table name instead of splitting it up into schema catalog table names
Hib,positive,perhaps this should be an exception since it is only ever used in the above method ?
Hib,positive,note this assumes something about how propertyselectfragment is implemented by the subclass was tounqotedaliasstrings getdiscriminatorcolumnname before now tried to remove that unqoting and missing aliases
Hib,positive,put a placeholder in entries so we do not recurse back and try to save the same object again question should this be done before onsave is called ? likewise should it be done before onupdate ?
Hib,positive,before cascade todo should this be session instantiate persister ?
Hib,positive,todo we should throw an exception if we really know for sure that this is a detached instance rather than just assuming throw new staleobjectstateexception entityname id
Hib,positive,todo the order in which entities are saved may matter e g a particular transient entity may need to be saved before other transient entities can be saved keep retrying the batch of transient entities until either there are no transient entities left in transientcopycache or no transient entities were saved in the last batch for now just run through the transient entities and retry the merge
Hib,positive,todo if object was an uninitialized proxy this is inefficient resulting in two sql selects
Hib,positive,todo put this stuff back in to read snapshot from the second level cache needs some extra work
Hib,positive,todo not quite sure about the full implications of this
Hib,positive,this is kinda the best we can do
Hib,positive,trim done to workaround stupid oracle bug that cant handle whitespaces before a in a sp
Hib,positive,todo this need not exclude subclasses
Hib,positive,todo we use two visitors here inefficient
Hib,positive,trim done to workaround stupid oracle bug that cant handle whitespaces before a in a sp
Hib,positive,todo does this really need to be here ? does the collection already have it is own up to date snapshot ?
Hib,positive,otherwise a trim specification and or a trim character have been specified we need to decide which options are present and do the right thing should leading trim characters be trimmed ? should trailing trim characters be trimmed ? the trim character the trim source
Hib,positive,it is possible that the tree walking in outerjoinloader can get to an association defined by a subclass in which case the property ref might refer to a property defined on a subclass of the current class in this case the table name is not known this temporary solution assumes that the property ref refers to a property of the subclass table that the association belongs to a reasonable guess todo fix this add outerjoinloadable getsubclasspropertytablename string propertyname
Hib,positive,todo an alternative is to check if the owner has changed if it has not then return collection getowner
Hib,positive,i suppose ?
Hib,positive,tbd should this be varbinary ? registercolumntype types varbinary binary 
Hib,positive,shortcut
Hib,positive,todo we should provide some way to get keys of collection of statistics to make it easier to retrieve from a gui perspective
Hib,positive,todo probably better to calculate these and pass them in as it will be more performant
Hib,positive,todo should we additionally check the current isolation mode explicitly ?
Hib,positive,todo simply remove this override if we fix the above todos
Hib,positive,todo get sql rendering out of this package
Hib,positive,todo get sql rendering out of this package
Hib,positive,todo get sql rendering out of this package
Hib,positive,todo is there really any reason to kkeep trying if this fails once ?
Hib,positive,todo not sure this is correct could not find docs on how to do this
Hib,positive,hsql has no blob clob support but just put these here for now
Hib,positive,merges do not cascade to uninitialized collections todo perhaps this does need to cascade after all
Hib,positive,yick need this for proper serialization deserialization handling
Hib,positive,todo should orphans really be deleted during lock ? ? ?
Hib,positive,todo move to stringhelper ?
Hib,positive,sets can be just a view of a part of another collection do we need to copy it to be sure it wo not be changing underneath us ? ie this set addall set
Hib,positive,todo it would be really really nice to use this to also model components
Hib,positive,todo move to sql package
Hib,positive,todo look at the owning property and check that it is not lazy by instrumentation
Hib,positive,todo add this info to the translator and aggregate it here
Hib,positive,todo possibly relax that
Hib,positive,todo possibly relax that
Hib,positive,would be better to use the element type to determine whether the old and the new are equal here the problem being we do not necessarily have access to the element type in all cases
Hib,positive,todo code duplication with joinedsubclassentitypersister
Hib,positive,todo refactor to sql package
Hib,positive,todo two hashmap lookups here is one too many
Hib,positive,note that this method could easily be moved up to basicentitypersister if we ever needed to reuse it from other subclasses
Hib,positive,from the collection of associations locate oja for the manytoone corresponding to this persister to fully define the many to many we need that oja so that we can use its alias here todo is there a better way here ?
Hib,positive,todo this class depends directly upon criteriaimpl in the impl package add a criteriaimplementor interface
Hib,positive,do we need to qualify index names with the schema name ?
Hib,positive,todo we probably should have a statisticsnotpublishedexception to make it clean
Hib,positive,todo get sql rendering out of this package
Hib,positive,yukky do not you have subclasses for that todo race conditions can happen here
Hib,positive,note very hackish workaround todo fix this so it will work for non pojo entity mode
Hib,positive,todo need to make the majority of this functionality into a top level support class for custom impl support
Hib,positive,for dom j collections only todo it would be better if this was done at the higher level by printer
Hib,positive,todo inefficient if that cache is just going to ignore the updated state
Hib,positive,todo an alternative is to check if the owner has changed if it has not then get the id from collection getowner
Hib,positive,todo refactor make this method private
Hib,positive,todo keep seperate notions of qt here for shallow non shallow queries
Hib,positive,todo temporary needed because currently persister is the one that creates and renders the join fragments for inheritence hierarchies
Hib,positive,this is called by sessionfactory irregardless we just disregard here could also add a check to sessionfactory to only conditionally call stop
Hib,positive,swaldman modify to allow null values to signify fall through to c p poolconfig defaults
Hib,positive,work around that crazy issue where the tree contains empty fromelements no text afaict this is caused by fromelementfactory createcollectionjoin
Hib,positive,kinda ugly but needed for collections with a node mapping
Hib,positive,fixme get the persistentclass
Hib,positive,todo would be great to have a mapping hasnonidentifierpropertynamedid method i do not believe that mapping getreferencedpropertytype accounts for the identifier property so if it returns for a property named  id  then we should have a non id field named id
Hib,positive,entity name will not be available for non pojo entities todo cache the entity name somewhere so that it is available to this exception
Hib,positive,todo is this really necessary ? ? ? ?
Hib,positive,index getpropertycolumnspan i todo this is kinda slow
Hib,positive,todo move to sql package and refactor with similar things
Hib,positive,todo i am not so sure about the exception handling in this bit
Hib,positive,ugly little workaround for fact that createuniquekeyloaders does not handle component properties
Hib,positive,append the sql to return the generated identifier todo suck into insert
Hib,positive,this is really ugly but necessary
Hib,positive,todo modify the class definition if not already transformed
Hib,positive,todo should we use select for update ?
Hib,positive,create an action that will evict collection and entity regions based on queryspaces table names todo cache the autodetected information and pass it in instead
Hib,positive,todo is this correct ?
Hib,positive,used only for regression testing todo obviously get rid of all this junk
Hib,positive,note this assumes something about how propertyselectfragment is implemented by the subclass was tounqotedaliasstrings getidentifercolumnnames before now tried to remove that unqoting and missing aliases
Hib,positive,use of a stringbuffer to workaround a jdk bug
Hib,positive,todo move into collection type so we can use polymorphism
Hib,positive,todo should we just collect these like with the collections above ?
Hib,positive,todo should really move this log statement to collectiontype where this is used from
Hib,positive,fixme hacky workaround to jbcache 
Hib,positive,hum should we cascade anyway ? throw an exception ? fine like it is ?
Hib,positive,todo this might really even be moved into the cfg package and used as the basis for all things which are configurable
Hib,positive,todo copy paste from insertrows
Hib,positive,todo suck into event class
Hib,positive,todo never reached since gettypename actually throws an exception
Hib,positive,this is used by sessionfactoryimpl to hand to the generated sessionimpl was the only reason i could see that we cannot just use null as settings cacheprovider
Hib,positive,xmlforest requires a new kind of function constructor
Hib,positive,todo is this a valid operation on a timestamps cache ?
Hib,positive,todo i considered validating the presence of the ts cache here but decided to defer unti getquerycacheinstance in case the cache is never actually used
Hib,positive,todo why not use the timestamp in a dataversion ?
Hib,positive,todo eventually merge this with treecache and just add optional opt lock support there
Hib,positive,fixme per the regionfactory class javadoc this constructor version should not be necessary param props the configuration properties
Hib,positive,fixme per the regionfactory class javadoc this constructor version should not be necessary param props the configuration properties
Hib,positive,work around the feature where tree cache is validating the inserted node during the next transaction no idea
Hib,positive,fixme per the regionfactory class javadoc this constructor version should not be necessary param props the configuration properties
Hib,positive,todo i considered validating ts cache config here but decided to defer unti gettimestampscacheinstance in case the cache is never actually used
Hib,positive,can happen because of the multiple ways cache remove can be invoked
Hib,positive,need to do that here rather than in the save event listener to let the post insert events to have a id filled entity when identity is used ejb 
Hib,positive,unhappy about this being public is there a better way ?
Hib,positive,todo safe to interpret map remove key null as non dirty ?
Hib,positive,fixme hack to work around fact that calling node added root addchild fqn does not properly set the version on the node
Hib,positive,work around the feature where tree cache is validating the inserted node during the next transaction no idea
Hib,positive,todo is this a valid operation on a timestamps cache ?
Hib,positive,todo what else to do here ?
Hib,positive,todo replace this with a more elegant solution
Hib,positive,short cut check
Hib,positive,todo to handle concurrent writes correctly this should return a lock to the client
Hib,positive,put has nowait semantics is this really appropriate ? note that it needs to be async replication never local or sync
Hib,positive,this is ugly here but needed because its a subquery
Hib,positive,todo will need reference to session factory to fully complete hhh 
Hib,positive,yuck
Hib,positive,inheritance cycle detection paranoid check
Hib,positive,todo remove
Hib,positive,todo encapsulate the protected instance variables
Hib,positive,polymorphism comment above
Hib,positive,todo find a decent name before documenting
Hib,positive,add an entry for this type of entity we can be assured that all referenced entities have already been processed so specify that this entity is with the latest batch doing the batch number before adding the name to the list is a faster way to get an accurate number
Hib,positive,todo handle typedefs
Hib,positive,todo get all properties not just the fetched ones
Hib,positive,todo native ids
Hib,positive,todo bindpropertyresults alias returnelem
Hib,positive,todo handle property ref
Hib,positive,todo validate existing of property with the chosen name secondpass
Hib,positive,todo get all properties not just the fetched ones
Hib,positive,todo check that entry getidentifier equals requestedid
Hib,positive,todo restrict violation
Hib,positive,todo assertion only could be optimized away
Hib,positive,todo lowercasing done here was done at random before maybe not needed at all ?
Hib,positive,todo optimize away this lookup for entities w o unsaved value undefined
Hib,positive,todo tolowercase was not done before only used in template
Hib,positive,todo arithmetic expressions multiple new foo
Hib,positive,todo check that entry getidentifier equals requestedid
Hib,positive,todo not visible to the user
Hib,positive,todo proxies
Hib,positive,todo can we limit stored procedures ?
Hib,positive,todo formulas ?
Hib,positive,todo better error message since we actually support composites if names are explicitly listed
Hib,positive,todo use these in methods above
Hib,positive,todo cache the persister this shows up in yourkit
Hib,positive,todo add referencedclass to disambiguate to fks on the same columns pointing to different tables
Hib,positive,todo create uk loaders for component properties
Hib,positive,todo still need to make collectionpersisters entitymode aware
Hib,positive,todo terrible implementation
Hib,positive,todo eventually put this back in once we think all is fixed object otheralias columnsunique put qualifiedcolumn columnalias
Hib,positive,todo i do not really like this implementation it would be better if this was handled by searchfordirtycollections
Hib,positive,todo check if key contains the owner id
Hib,positive,todo cache this in an instvar
Hib,positive,todo temporary initial step towards hhh 
Hib,positive,todo remove this once componentmetamodel is complete and merged
Hib,positive,todo add owner argument
Hib,positive,todo handle supportsnotnullunique false but such a case does not exist in the wild so far
Hib,positive,todo better error message since we actually support composites if names are explicitly listed
Hib,positive,todo for some dialects it would be appropriate to add the renderorderbypropertiesselect to other select strings
Hib,positive,todo unnecessary for databases with ansi style joins
Hib,positive,todo maybe call it getrowselection ?
Hib,positive,todo make this handle multiple collection roles
Hib,positive,todo include the rowids
Hib,positive,if we are still not resolved we might represent a constant needed to add this here because the allowance of naked prop refs in the grammar collides with the definition of literals constants nondeterminism todo cleanup the grammar so that processconstants is always just handled from here
Hib,positive,todo or should we return  containstablealias  ? ?
Hib,positive,todo look at perhaps caching this
Hib,positive,todo avoid this for non new instances where mightbedirty false
Hib,positive,todo theoretically non threadsafe
Hib,positive,todo look at optimizing these
Hib,positive,todo cache this sql
Hib,positive,todo check if mimer sql cannot handle the way db does
Hib,positive,todo if we are using identity columns fetch the identifier
Hib,positive,todo check there is no actual definition elemnents when a ref is defined
Hib,positive,table null an association fill it in later todo fill in the mappings for table null
Hib,positive,table null an association fill it in later todo fill in the mappings for table null
Hib,positive,todo add support for read write nonstrict read write ? ? ?
Hib,positive,todo return new lock ts
Hib,positive,todo add support for read write nonstrict read write ? ? ?
Hib,positive,todo why are not these the same ?
Hib,positive,todo proxies
Hib,positive,todo proxies
Hib,positive,todo if we support multiple fetch groups we would need to clone the set of lazy properties
Hib,positive,todo mappings getlogicaltablename ownertable
Hib,positive,todo if lock gettimestamp equals ts
Hib,positive,todo always true for now but not if we later decide to support elements in the from clause
Hib,positive,we could move this inside if we wanted to tolerate collection initializations during collection dirty checking
Hib,negative,see if the user configured a multiplexer stack
Hib,negative,root entity comes last
Hib,negative,elementtype ? ?
Hib,negative,scan the query string for class names appearing in the from clause and replace with all persistent implementors of the class interface returning multiple query strings make sure we do not pick up a class in the select clause
Hib,negative,identifier collections not supported for to many
Hib,negative,potentialtrimcharacterargindex assumes that a trim specification has been specified we handle the exception to that explicitly
Hib,negative,overridden informational metadata
Hib,negative,if the current depth is the root thing being loaded is the many to many collection itself here it is alright to use an inner join
Hib,negative,update removed rows fks to null
Hib,negative,registerfunction trim new standardsqlfunction trim hibernate string
Hib,negative,buf append selectfragment lhsalias ignore suffix for collection columns
Hib,negative,initialize the set of queried identifier spaces ie tables
Hib,negative,use suffix for the entity columns
Hib,negative,we got here because we assumed that an instance with an assigned id was detached when it was really persistent
Hib,negative,the class hierarchy structure
Hib,negative,remove the current element from insertions it will be added back later
Hib,negative,private final string roottablename
Hib,negative,note this is being used from the process of shutting down a sessionfactory specific things to consider this clearing of the region should not propagate to other nodes on the cluster if any this is the cache mode local option bit really just trying a best effort to cleanup after ourselves lock failures etc are not critical here this is the fail silently option bit
Hib,negative,initialization
Hib,negative,stuff that is persister centric and or entityinfo centric
Hib,negative,not null start with is implicit
Hib,negative,continue loop
Hib,negative,return existing object or initialized proxy unless deleted
Hib,negative,the list of entity names that indicate the batch number
Hib,negative,disassembled state gets put in a new array we write to cache by value
Hib,negative,add these directly to the executions queue
Hib,negative,execute the sql
Hib,negative,sort the updates by fk
Hib,negative,this could also just be true all the time
Hib,negative,the mapping of entity names to their latest batch numbers
Hib,negative,chop the last union all
Hib,negative,note that for sequential scrolling we make the assumption that the first persister element is the root entity
Hib,negative,todo check this
Hib,negative,for deprecated saveorupdatecopy
Hib,negative,initialization
Hib,negative, check constraint violation unique index or primary key violation 
Hib,negative,the closure of all properties in the entire hierarchy including subclasses and superclasses of this class
Hib,negative,expressionterminators add deliberately excluded
Hib,negative,subclass discrimination works by assigning particular values to certain combinations of null primary key values in the outer join using an sql case
Hib,negative,tokens that close a sub expression tokens that open a sub expression tokens that would indicate a sub expression is a boolean expression
Hib,negative,multi param numeric dialect functions
Hib,negative,use theta style for regression move the node up after the origin node
Hib,negative,multi param date dialect functions
Hib,negative,overridden informational metadata
Hib,negative,add the main query
Hib,negative,sqlexception support
Hib,negative,add the restriction to the outer select
Hib,negative,bit length feels a bit broken to me we have to cast to char in order to pass when a numeric value is supplied but of course the answers given will be wildly different for these two datatypes will be bytes as a char string but will be or bytes as a true numeric jay nance 
Hib,negative,this assumes you will want to ignore any update counts
Hib,negative,skip the from keyword in params
Hib,negative,custom sql
Hib,negative,return a newly loaded object
Hib,negative,make it circular reference safe
Hib,negative,cope with special cases of and not
Hib,negative,subclass closure properties
Hib,negative,for dialects which are known to not support ansi sql row value constructor syntax we should mutate the tree
Hib,negative,overridden informational metadata
Hib,negative,we have the form trim from trimsource this is functionally equivalent to trim trimsource early exit
Hib,negative,subclasses
Hib,negative,need to hydrate it
Hib,negative,starts with implicitly
Hib,negative,instantiate a new instance
Hib,negative,simple nullability constraint
Hib,negative,we need to upgrade the lock mode to the mode requested
Hib,negative,register the type of the out param an oracle specific type
Hib,negative,look for a proxy
Hib,negative,features which change between i i and g
Hib,negative,evicts do not cascade to uninitialized collections
Hib,negative,features which remain constant across i i and g
Hib,negative,need to treat this as if it where optimistic lock all dirty does not make sense first we need to locate the loaded state note it potentially could be a proxy so perform the location the safe way
Hib,negative,column sc gettable getprimarykey getcolumniterator next getname
Hib,negative,might happen with a managed connection
Hib,negative,do not need subclass tables because they ca not appear in conditions
Hib,negative,not final static to avoid possible classcast exceptions if using different oracle drivers
Hib,negative,make certain that this is called before any subsequent scheduledupdate aftertransactioncompletion
Hib,negative,private list aliases new arraylist
Hib,negative,the reason for this is sql does not let you sort by an expression you are not returning in the result set
Hib,negative,register resolvers set via environment property
Hib,negative,an existing collection that was either non empty or uninitialized is replaced by null or a different collection if the collection is uninitialized hibernate has no way of knowing if the collection is actually empty without querying the db
Hib,negative,update all the modified entries
Hib,negative,special case where we need to force incloude all subclass joins
Hib,negative,we did not find a collection element in the result set so we ensure that a collection is created with the owner is identifier since what we have is an empty collection
Hib,negative,binary stream character stream
Hib,negative,ignore it
Hib,negative,getdefaultproperties setproperty environment statement batch size no batch
Hib,negative,assumes that types are all of span 
Hib,negative,hibernate impelemnts cast in dialect java
Hib,negative,this is the root versioned table and we are using version based optimistic locking if we are not updating the version also do not check it unless this is a generated version column
Hib,negative,aggregate functions should not be registered right ? registerfunction list new standardsqlfunction list hibernate string stopped on list
Hib,negative,its the given optional object
Hib,negative,the class hierarchy structure
Hib,negative,decide which resultset to get the property value from
Hib,negative,properties of this class including inherited properties
Hib,negative,otherwise assume the parent is the the criteria that created us
Hib,negative,the closure of all columns used by the entire hierarchy including subclasses and superclasses of this class
Hib,negative,we can go straight to the first required row
Hib,negative,now look up the object we are really interested in this lets us correctly handle proxies and multi row or multi column queries
Hib,negative,before adding to collection
Hib,negative,discriminator column
Hib,negative,code to handle subclasses of topclass
Hib,negative,initialization
Hib,negative,none because its the requested lock mode not the actual
Hib,negative,private final map propertytablenumbersbyname new hashmap
Hib,negative,conceivable that the dialect ctor could throw hibernateexceptions so do not re wrap
Hib,negative,class table
Hib,negative,synchronized to avoid multi thread access issues defined as method synch to avoid potential deadlock issues due to nature of code
Hib,negative,required to exception table iconst i
Hib,negative,for now just re flatten the metamodel since this is temporary stuff anyway hhh 
Hib,negative,checkcast cast the bean into a raw bean
Hib,negative,this one only really needed for badly behaved applications if the transactionmanager has a sychronization registered its a noop actually we do need it for downgrading locks
Hib,negative,checkcast case of primitive type invokevirtual case of primitive type
Hib,negative,at this point we have drivingsqlalias the sql alias of the driving table corresponding to the given user alias however the driving table is not necessarily the table against which we want to apply locks mainly the exception case here is joined subclass hierarchies where we instead want to apply the lock against the root table for all other strategies it just happens that driving and root are the same
Hib,negative,this bean args i raw bean exception
Hib,negative,get the first child to be considered sub classes may do this differently in order to skip nodes that are not select expressions e g distinct
Hib,negative,new bulkaccessorexception
Hib,negative,as is not in keywords
Hib,negative,getfield get field javassist callback defined already
Hib,negative,all distinctrootentityresulttransformer are considered equal
Hib,negative,dup
Hib,negative,todo move this to sf per hhh also see hhh and componentmetamodel
Hib,negative,putfield put field javassist callback defined already
Hib,negative,configure the cache to use our tm
Hib,negative,local variables this callback
Hib,negative,find the batch number associated with the current association if any
Hib,negative,invokeinterface
Hib,negative,we always assume an instance with a null identifier or no identifier property is unsaved
Hib,negative,ddl support
Hib,negative,seems to not really public boolean supportsrowvalueconstructorsyntax return true
Hib,negative,below is for cache  that do not have str in there is str and we register str directly
Hib,negative,temporary
Hib,negative,byte
Hib,negative,the column doesnt exist at all
Hib,negative,note that string is deprecated
Hib,negative,if the object is already loaded return the loaded one
Hib,negative,create new lock that times out immediately
Hib,negative,convenience methods relating to operations across arrays of types
Hib,negative,we really could refresh the item if it is not a lock but it might be slower return freshtimestamp txtimestamp
Hib,negative,due to the complexity in initializing the selectclause do not generate one here if it is not found simply return null also do not cache since it gets generated well after we are created
Hib,negative,discriminator
Hib,negative,versiontype impl note simply returns null for seed and next as the only known application of binary types for versioning is for use with the timestamp datatype supported by sybase and sql server which are completely db generated values
Hib,negative,pre flushing section
Hib,negative,use the lower case function name remember whether we  re in a select clause or not
Hib,negative,upper is deprecated
Hib,negative,let this take precedence if defined since it works for assigned identifiers
Hib,negative,throw new unsupportedoperationexception ca not write to a readonly object
Hib,negative,the contract of entitytuplizer determineconcretesubclassentityname says that returning null is an indication that the specified entity name this getentityname should be used
Hib,negative,subclasses
Hib,negative,according to both the ansi sql and ejb specs trim can either take exactly one parameter or a variable number of parameters between and from the sql spec trim function trim left paren trim operands right paren trim operands trim specification trim character from trim source trim specification leading trailing both if only trim specification is omitted both is assumed if trim character is omitted space is assumed
Hib,negative,the syntax used to add a foreign key constraint to a table
Hib,negative,note it is conceptually possible that a usertype could map null to a non null value so the following is arguable
Hib,negative,execute the sql
Hib,negative,note interfaces is assumed to already contain hibernateproxy class
Hib,negative,identifier commalist
Hib,negative,note interfaces is assumed to already contain hibernateproxy class
Hib,negative,assembled state gets put in a new array we read from cache by value
Hib,negative,we do not have to worry about queued additions to uninitialized collections since they can only occur for inverse collections
Hib,negative,disassemble named parameters
Hib,negative,if not wrappered yet its dirty this ca not occur because we now always call wrap before getting to here return obj instanceof persistentcollection ? true searchfordirtycollections persistentcollection obj type
Hib,negative,again ccs did not have such a concept but a reasonable proximity is to clear the cache after transaction as long as the underlying cache is not jta aware
Hib,negative,oracle driver reports to support getgeneratedkeys but they only support the version taking an array of the names of the columns to be returned via its returning clause no other driver seems to support this overloaded version
Hib,negative,again ccs did not have such a concept however a reasonable proximity is to clear the cache for non transaction aware caches we will also do a clear at the end of the transaction
Hib,negative,remove all collections for the entity from the session level cache
Hib,negative,invokeinterface callback write
Hib,negative,moved up from abstractentitypersister
Hib,negative,joins
Hib,negative,if this is an entity and the property is the identifier property then use getidentifiertype note that the propertyname equals propertypath checks whether we have a component key reference where the component class property name is the same as the entity id property name if the two are not equal this is the case and we  d need to fall through to using the property mapping
Hib,negative,classes mentioned in extends not available so put it in queue
Hib,negative,stuff that is tuplizer centric
Hib,negative,propertytablenumbersbyname put prop getname join
Hib,negative,needed to bump this up to dotnode because that is the only thing which currently knows about the property ref path in the correct format it is either this or recurse over the dotnodes constructing the property path just like dotnode does internally
Hib,negative,access cached sql
Hib,negative,stuff that is tuplizer centric but is passed a session
Hib,negative,figure out which tables need to be fetched
Hib,negative,private final list persisters new arraylist
Hib,negative,figure out which columns are needed
Hib,negative,it is possible for this method to be called during flush processing so make certain that we do not accidently initialize an uninitialized proxy
Hib,negative,figure out which formulas are needed
Hib,negative,get em on the second pass
Hib,negative,render the sql
Hib,negative,local cache so we use synchronization
Hib,negative,sql strings
Hib,negative,public static object clone class elementclass object array object result object array newinstance elementclass array length system arraycopy array result array length return result
Hib,negative,identity support
Hib,negative,if there is no resulting row return null
Hib,negative,load each type
Hib,negative,unfortunately not really safe to normalize this to as an initial value like we do the others because we would not be able to control this if we are using a sequence
Hib,negative,
Hib,negative,select topic syntax from information schema help where section like  function   order by section topic see also http www h database com html functions html
Hib,negative,the optional sql string defined in the where attribute
Hib,negative,pass this as an argument only to avoid double looking
Hib,negative,for version properties marked as being generated make sure they are always generated aka insert is invalid this is dis allowed by the dtd but just to make sure
Hib,negative,added this caching as i noticed that gettype is being called multiple times
Hib,negative,information about lazy properties of this class
Hib,negative,if there are any scalars non entities selected render the select column aliases
Hib,negative,information about all columns formulas in class hierarchy
Hib,negative,inner classes
Hib,negative,column discrim getcolumniterator next settype type
Hib,negative,saveorupdatecopy operations
Hib,negative,dynamic filters attached to the class level
Hib,negative,the loaded owner will be set to null after the collection is removed so capture its value as the affected owner so it is accessible to both pre and post events
Hib,negative,temporary table support
Hib,negative,assume we are in an auto commit state
Hib,negative,custom sql
Hib,negative,cascade first so that all unsaved objects get their copy created before we actually copy cascadeonmerge event persister entity copycache cascades cascade before merge
Hib,negative,model getkey settype new type model getidentifier
Hib,negative,stuff that is tuplizer centric
Hib,negative,the syntax used to add a column to a table
Hib,negative,simple because we ca not have a one to one or a collection or even a property ref in a composite element
Hib,negative,completely optional cascading drop clause
Hib,negative,during deserialization we need to reconnect all proxies and collections to this session as well as the entityentry and collectionentry instances these associations are transient because serialization is used for different things
Hib,negative,properties
Hib,negative,sqlresulttypes type sqlresulttypelist toarray new type sqlresulttypelist size
Hib,negative,
Hib,negative,potentialtrimcharacterargindex assumes that a trim specification has been specified we handle the exception to that explicitly
Hib,negative,identifier
Hib,negative,we call getkeyfromresultset here so that we can know the key value upon which to perform the breaking logic however it is also then called from getrowfromresultset which is certainly not the most efficient but the call here is needed and there currently is no other way without refactoring of the doquery getrowfromresultset methods
Hib,negative,version
Hib,negative,operations which cascade as far as the collection also cascade to collection elements
Hib,negative,where string
Hib,negative,the loop ensures atomicity of the select update even for no transaction or read committed isolation level
Hib,negative,subclass property closure
Hib,negative,in an effort to avoid concurrent modification exceptions from potential recursive calls back through here as a result of the eventual call to persistentcollection endread we scan the internal loadingcollections map for matches and store those matches in a temp collection the temp collection is then used to drive the endread processing
Hib,negative,before add
Hib,negative,the configured transaction factory says it only supports local callback mode so no sense attempting to register a jta synchronization
Hib,negative,handle any filters applied to the class level
Hib,negative,sybase driver jconnect throwing npe here in certain cases but we will just handle the general unexpected case
Hib,negative,only one to one is lazy fetched
Hib,negative,replicate does cascade to uninitialized collections
Hib,negative,note early exit here
Hib,negative,translates an ast join type i e the token type into a joinfragment xxx join type param astjointype the ast join type from hqlsqltokentypes or sqltokentypes return a joinfragment xxx join type see joinfragment see sqltokentypes
Hib,negative,note this assumes something about how propertyselectfragment is implemented by the subclass
Hib,negative,deliberately ignore return value
Hib,negative,strip leading
Hib,negative,if the metadata allowed proxy creation and caller did not request forceful eager loading generate a proxy
Hib,negative,if there is no resulting row return null
Hib,negative,if this from element is a collection and the path is a collection property maxindex etc then generate a sub query
Hib,negative,otherwise return the hydrated state ie associations are not resolved
Hib,negative,the name of the sql function that transforms a string to lowercase
Hib,negative,null owner ok ? ?
Hib,negative,essentially if the real session is closed allow any method call to pass through since the real session will complain by throwing an appropriate exception note that allowing close above has the same basic effect but we capture that there simply to perform the unbind
Hib,negative,automatically makes a column with the default name if none is specifed by xml
Hib,negative,just ignore
Hib,negative,this is the exception returned by reflecthelper getconstructor if it cannot locate an appropriate constructor
Hib,negative,ok in normal hibernate usage to delete a detached entity jpa however forbids it thus this is a hook for hem to affect this behavior
Hib,negative,null sql means that the only lazy properties are shared pk one to one associations which are handled differently in the type nullsafeget code
Hib,negative,if the property mapping consists of all formulas make it non updateable
Hib,negative,the user specifically supplied insert true which constitutes an illegal combo
Hib,negative,if the property mapping consists of all formulas make it insertable
Hib,negative,it might be an unwrapped collection reference try to find a wrapper slowish
Hib,negative,custom sql
Hib,negative,tablename mappings getnamingstrategy propertytotablename classname path
Hib,negative,package
Hib,negative,return
Hib,negative,the entry will be removed after the flush and will no longer override the stale snapshot this is now handled by removeentity in entitydeleteaction persistencecontext removedatabasesnapshot key
Hib,negative,bad cast
Hib,negative,arraylist list new arraylist list addall getkey getconstraintcolumns list addall getindex getconstraintcolumns getcollectiontable createuniquekey list
Hib,negative,property refs for associations defined on a component are not supported so no need to slice
Hib,negative,we have an embedded composite identifier
Hib,negative,if there is no property ref assume the join is to the subclass table ie the table of the subclass that the association belongs to
Hib,negative,stops flush being called multiple times if this method is recursively called
Hib,negative,create a new from node for the referenced class
Hib,negative,custom sql
Hib,negative,performance op to avoid the array search
Hib,negative,now get an existing proxy for each row element if there is one
Hib,negative,orphan delete used for programmer error detection
Hib,negative,empty means no scoping
Hib,negative,enable for hhh which we do not like
Hib,negative,lockmode anything
Hib,negative,this forcecacherefresh forcecacherefresh
Hib,negative,this is a collection initializer so we must create a collection for each of the passed in keys to account for the possibility that the collection is empty and has no rows in the result set
Hib,negative,an embedded component composite ids and unique note that this does not handle nested components
Hib,negative,and perform the load
Hib,negative,aliases
Hib,negative,cache these since they are stateless this one could even be static
Hib,negative,a nested composite element
Hib,negative,stuff that is tuplizer centric but is passed a session
Hib,negative,must occur after resolving identifiers
Hib,negative,get the persister for the subclass
Hib,negative,aliases for composite id is
Hib,negative,sqlqueryparser parser new sqlqueryparser sqlquery processor getalias persister processor getalias return aliases collaliases collpersisters suffixes collsuffixes sql parser process namedparameterbindpoints parser getnamedparameters
Hib,negative,fetch embedded identifiers propertynames from the virtual identifier component
Hib,negative,we need to grab the version value from the entity otherwise we have issues with generated version entities that may have multiple actions queued during the same flush
Hib,negative,embedded composite ids alias idname alias idname 
Hib,negative,note we need to do the wrap here even if its not dirty because collections need wrapping but changes to them do not dirty the container also for versioned data we need to wrap before calling searchfordirtycollections
Hib,negative,todo skip formulas ?
Hib,negative,guid support
Hib,negative,invokeinterface invoke enabled getinterceptfieldcallback
Hib,negative,hibernate seems to ignore this type
Hib,negative,do not need filters for the static loaders
Hib,negative,the user requested a greater i e more restrictive form of pessimistic lock
Hib,negative,do two passes for collection property ref
Hib,negative,public boolean droptemporarytableafteruse we have to because postgres sets current tx to rollback only after a failed create table return true
Hib,negative,select the correct row by either pk or rowid
Hib,negative,optimizer getfactory getsettings getbytecodeprovider getreflectionoptimizer mappedclass getternames setternames proptypes
Hib,negative,todo eventually rowidname j
Hib,negative,include the discriminator and class level where but not filters
Hib,negative,lazy join
Hib,negative,not absolutely necessary but helps for some equals hashcode implementations
Hib,negative,this is a property of the table which we are updating
Hib,negative,if the hibernate mapping did not specify a schema catalog use the defaults specified by properties but note that if the schema catalog were specified in hibernate mapping or as params they will already be initialized and will override the values set here they are in identifiergeneratorproperties
Hib,negative,this should only be possible if the caches are constructor injected
Hib,negative,transactions marked for rollback only cause some tm impls to throw exceptions
Hib,negative,special shortcut for id properties skip the join this must only occur at the end of a path expression
Hib,negative,impl note due to the delayed population of setters setters cached for performance we really cannot pro perly define equality for this transformer
Hib,negative,column simplevalue ic getindex getcolumniterator next setnullable false
Hib,negative,we have a mapped identifier property and the root of the incoming property path matched that identifier property
Hib,negative,contained elements
Hib,negative,
Hib,negative,for non inverse one to many with a not null fk add a backref
Hib,negative,to stop the class from being unloaded
Hib,negative,mappings might contain either the raw extends name in the case of an entity name mapping or a fqn in the case of a pojo mapping
Hib,negative,for objects that came in via update
Hib,negative,use dialect default properties
Hib,negative,increment the version number if necessary
Hib,negative,the cache provider is needed when we either have second level cache enabled or query cache enabled note that usesecondlevelcache is enabled by default
Hib,negative,information about all properties in class hierarchy
Hib,negative,string provider properties getproperty environment bytecode provider log info bytecode provider name provider bytecodeprovider bytecodeprovider buildbytecodeprovider provider settings setbytecodeprovider bytecodeprovider
Hib,negative,informational metadata
Hib,negative,we are using all or dirty property based optimistic locking
Hib,negative,orphans should be deleted during save update
Hib,negative,maybe a concrete sqlpropertyresult type but map is exactly what is required at the moment
Hib,negative,for some reason the antlr commonast initialization routines force this method to get called twice the first time with an empty string
Hib,negative,do a check
Hib,negative,sqlaliassuffixes i element getcolumnaliassuffix
Hib,negative,void setshowsqlenabled boolean b showsql b void setformatsqlenabled boolean b formatsql b
Hib,negative,materialize associations and initialize the object later
Hib,negative,private componenttuplizerfactory componenttuplizerfactory todo hhh and hhh 
Hib,negative,fetch join overrides default laziness fetch join overrides default laziness
Hib,negative,drop them in reverse order in case db needs it done that way
Hib,negative,this check is needed since processing leaves the cursor after the last physical row for the current logical row thus if we are after the last physical row this might be caused by either scrolling to the last logical row scrolling past the last logical row in the latter scenario the previous logical row really is the last logical row in all other cases we should process back two logical records the current logic row plus the previous logical row
Hib,negative,the owning entity may have been deleted and its identifier unset due to identifier rollback in which case try to look up its identifier from the persistence context
Hib,negative,build an array with indices equal to the total number of actual returns in the result hibernate will return for this query scalars non scalars
Hib,negative,public componenttuplizerfactory getcomponenttuplizerfactory return componenttuplizerfactory
Hib,negative,mckoi has no known variation of a select for update syntax
Hib,negative,it is or was referenced somewhere
Hib,negative,should be ok performance wise to generate new delegate instances for each request since these are locally stack scoped besides it makes the code much easier to read than the old transactionhelper stuff
Hib,negative,nothing to do even if the operand is a parameter no way we could infer an appropriate expected type here
Hib,negative,the root of the incoming property path matched one of the embedded composite identifier properties
Hib,negative,add normal properties
Hib,negative,serialization
Hib,negative,add the discriminator
Hib,negative,handles arrays and newly instantiated collections
Hib,negative,if either its role changed
Hib,negative,noncritical swallow and let the other propagate
Hib,negative,we will need to create new entries
Hib,negative,this piece is needed for usage in select clause
Hib,negative,no op we do not own the cache so we should not stop it
Hib,negative,key is an entity involved with the operation performed by the listener value can be either a copy of the entity or the entity itself
Hib,negative,get the names of the columns used to link between the collection owner and the collection elements
Hib,negative,let is assume that there is only one lazy fetch group for now
Hib,negative,more specifically ? op datetime if the operator is minus the param needs to be of some datetime type if the operator is plus the param needs to be of some numeric type
Hib,negative,do not even bother trying to read any further
Hib,negative,add normal properties
Hib,negative,prepend value and type list with null for any positions before the wanted position
Hib,negative,referencedcolumnname not used for backward compatibility
Hib,negative,static helper methods
Hib,negative,add the discriminator
Hib,negative,base expectation impls
Hib,negative,this property belongs on the table and is to be inserted
Hib,negative,need to extract the component values and check for subtype replacements
Hib,negative,add the primary key
Hib,negative,note that for sequential scrolling we make the assumption that the first persister element is the root entity
Hib,negative,impl note allows multiple collection fetches as long as the entire fecthed graph still points back to a single root entity for return
Hib,negative,registercolumntype types blob mediumblob registercolumntype types blob blob
Hib,negative,delegate already handles pk columns
Hib,negative,properties of this class including inherited properties
Hib,negative,ie e status deleted
Hib,negative,kept for backward compatibility until after the beta release of ha
Hib,negative,legacy behavior apply the bridge
Hib,negative,if an exception occurs during flush user must call rollback
Hib,negative,turn off includesubclasses on all fromelements
Hib,negative,ca not just return null here since that would cause an owning component to become null
Hib,negative,the object is transient or detached
Hib,negative,now update only the tables with dirty properties and the table with the version number
Hib,negative,render the sql query
Hib,negative,we must return a valid rdms rsa command from this method to prevent rdms rsa from issuing error 
Hib,negative,write the values of fields onto the prepared statement we must use the state at the time the insert was issued cos of foreign key constraints not necessarily the object is current state
Hib,negative,registercolumntype types varbinary character l registercolumntype types blob character l for use prior to cp registercolumntype types clob character l
Hib,negative,todo shouldnt inserts be expectations none ?
Hib,negative,a proxy cannot be transient and it breaks foreignkeys istransient
Hib,negative,do not bother trying to update we know there is no row there yet
Hib,negative,this is the root level node generate an explicit from clause at the root
Hib,negative,check
Hib,negative,actual cache of the entries soft references are used for both the keys and the values here since the values pertaining to the mru entries are kept in a seperate hard reference cache to avoid their enqueuement garbage collection
Hib,negative,if all fields are null we might need to delete existing row
Hib,negative,stops flush being called multiple times if this method is recursively called
Hib,negative,note updates to joined tables ca not be batched
Hib,negative,string functions
Hib,negative,starting index
Hib,negative,object have been loaded with setreadonly true hhh 
Hib,negative,build a resultsetmappingdefinition given a containing element for the return xxx elements param resultsetelem the element containing the return definitions param path no clue param mappings the current processing state return the description of the mappings
Hib,negative,private list collectionowneraliases new arraylist private list collectionaliases new arraylist private list collectionpersisters new arraylist private list collectionresults new arraylist
Hib,negative,write any appropriate versioning conditional parameters
Hib,negative,check if the detached object being merged is the parent
Hib,negative,render the sql query
Hib,negative,determine if the collection elements are entities
Hib,negative,do the key the key is immutable so we can use the current object state not necessarily the state at the time the delete was issued
Hib,negative,let return propertys override whatever the persister has for aliases
Hib,negative,we should use the current object state ie after any updates that occurred during flush
Hib,negative,might need to run a different filter entirely after the flush because the collection role may have changed
Hib,negative,amazingly these two will work because abstractcollection uses iterator to fill the array
Hib,negative,ca not cache this stuff either per invocation we are given a map of user alias lock mode create a new map of sql alias lock mode
Hib,negative,note dirtyfields null means we had no snapshot and we could not get one using select before update oldfields null just means we had no snapshot to begin with we might have used select before update to get the dirtyfields
Hib,negative,loop through all the associations of the current entity and make sure that they are processed before the current batch number
Hib,negative,parametercontainer impl
Hib,negative,temporary
Hib,negative,note that if we load this collection from a cartesian product the multiplicity would be broken so use an idbag instead
Hib,negative,column and table should be renamed but it would break the public api
Hib,negative,for many to many joins use the tablename from the queryable collection for the default text
Hib,negative,int result result result type hashcode result result value null ? value hashcode return result
Hib,negative,for the case of dynamic update true we need to generate the update sql
Hib,negative,merge operations
Hib,negative,default to collections sharing entity cache if there is one
Hib,negative,commented out by inspection am public abstract void addcondition string alias string columns string condition
Hib,negative,do not need to check laziness dirty checking algorithm handles that
Hib,negative,roottablename persistentclass getroottable getqualifiedname factory getdialect factory getdefaultcatalog factory getdefaultschema
Hib,negative,for the case of dynamic update false or no snapshot we use the static sql
Hib,negative,abort the save the object is already saved by a circular cascade
Hib,negative,if not get then try is
Hib,negative,remove initial and
Hib,negative,default to sharing the entity cache if there is one
Hib,negative,we have the form trim trimsource so we trim leading and trailing spaces
Hib,negative,for the case of dynamic insert true we need to generate the insert sql
Hib,negative,if it was a reference to self do not need to nullify unless we are using native id generation in which case we definitely need to nullify
Hib,negative,for the case of dynamic insert true we need to generate the insert sql
Hib,negative,the user visible aliases which are unknown to the superclass these are not the actual physical sql aliases
Hib,negative,for the case of dynamic insert false use the static sql
Hib,negative,if a composite key use foo ? and bar ? or foo ? and bar ? for batching todo unnecessary for databases with ansi style joins
Hib,negative,for the case of dynamic insert false use the static sql
Hib,negative,the class hierarchy structure
Hib,negative,a shortcut if its location did not change
Hib,negative,swaldman define c p style configuration parameters for properties with hibernate specific overrides to detect and warn about conflicting declarations
Hib,negative,not supported
Hib,negative,need to use the identifier type of the collection owner since the incoming is value is actually the owner is id using the collection is key type causes problems with property ref keys
Hib,negative,if we instantiate a collection during the flush process we must ignore it for the rest of the flush
Hib,negative,moved up from abstractentitypersister
Hib,negative,new collections that get found wrapped during flush should not be ignored
Hib,negative,meant to handle dynamic instantiation queries
Hib,negative,a newly wrapped collection is not dirty or we get unnecessary version updates
Hib,negative,local cache so we use synchronization
Hib,negative,always add the collection is query spaces
Hib,negative,the blob type requires a size arguement this defaults to bytes no arg defaults to whole byte other argument mods include k kilobyte m megabyte g gigabyte refer to the pbdevelopers guide for more info
Hib,negative,detached collections that get found reattached during flush should not be ignored
Hib,negative,revert to traditional hibernate behavior of setting initialpoolsize to minpoolsize unless otherwise specified with a c p style parameter
Hib,negative,we need to utilize dynamic delete statements
Hib,negative,columns add columnname aliases add tablealias
Hib,negative,otherwise utilize the static delete statements
Hib,negative,intentionally empty
Hib,negative,public boolean equals object other read return bag equals other public int hashcode object other read return bag hashcode
Hib,negative,final boolean forcecacherefresh
Hib,negative,just a performance opt
Hib,negative,essentially if we have a local hibernate transaction in progress and it already has the usertransaction cached use that usertransaction to determine the status if a transaction manager has been located use that transaction manager to determine the status finally as the last resort try to lookup the usertransaction via jndi and use that to determine the status
Hib,negative,just a performance opt
Hib,negative,used to set the type of the parent dot node
Hib,negative,all joins join to the pk of the driving table
Hib,negative,more specifically datetime op ? if the operator is minus we really cannot determine the expected type as either another datetime or numeric would be valid if the operator is plus the param needs to be of some numeric type
Hib,negative,notice that we skip the first table it is the driving table
Hib,negative,aliases named identifier alias idname
Hib,negative,skip the driving table
Hib,negative,inserts
Hib,negative,get  em in the right order not that it really matters
Hib,negative,package
Hib,negative,note early exit
Hib,negative,
Hib,negative,trying via forname first to be as close to drivermanager is semantics
Hib,negative,this bit is only really absolutely necessary for handling requestedid but is also good if we merge multiple object graphs since it helps ensure uniqueness
Hib,negative,private boolean showsql private boolean formatsql
Hib,negative,in case we were deserialized in a different jvm look for an instance with the same name alternatively we could do an actual jndi lookup here
Hib,negative,try to make sure we do not wrap and already wrapped session
Hib,negative,if this is an implied join in a from clause then use ansi style joining and set the flag on the fromelement that indicates that it was implied in the from clause itself
Hib,negative,render the where and from parts
Hib,negative,there is already an existing batch for this type of entity check to see if the latest batch is acceptable
Hib,negative,allow these to go through the the real session no matter what
Hib,negative,do not really know all the codes required to adequately decipher returned jdbc exceptions here simply allow the failure to be eaten and the subsequent insert selects deletes should fail
Hib,negative,we could regerate this inside each called method
Hib,negative,the cascadingaction implementations
Hib,negative,now render the joins
Hib,negative,if you  re closing down the connectionprovider chances are an is not a real big deal just warn
Hib,negative,create a new batch for this type the batch number is the number of current batches
Hib,negative,keyword support
Hib,negative,this will add the new from element to the origin
Hib,negative,the closure of all columns used by the entire hierarchy including subclasses and superclasses of this class
Hib,negative,now render the select clause
Hib,negative,the keyword used to insert a row without specifying any column values
Hib,negative,now tie it all together
Hib,negative,does the limit clause take a maximum row number instead of a total number of returned rows ?
Hib,negative,insert update delete sql
Hib,negative,the keyword used to specify a nullable column
Hib,negative,select sql
Hib,negative,overriden to avoid system exit
Hib,negative,no need to check laziness dirty checking handles that
Hib,negative,callable statement support
Hib,negative,fully resolve the map reference create implicit joins
Hib,negative,break the outer loop
Hib,negative,since this entity will now be processed in the latest possible batch we can be assured that it will come after all other associations there is not need to continue checking
Hib,negative,remove any snapshot not really for memory management purposes but rather because it might now be stale and there is no longer any entityentry to take precedence this is now handled by removeentity session getpersistencecontext removedatabasesnapshot key
Hib,negative,the basic implementation is to simply use the node is text
Hib,negative,intersystems cache  does not current support select for update syntax set your transaction mode to read committed before using
Hib,negative,cascade to current collection elements
Hib,negative,constructors
Hib,negative,not really necessary but good for consistency
Hib,negative,try to find out the name of the primary key to create it as identity if the identitygenerator is used
Hib,negative,we ca not cascade to non embedded elements
Hib,negative,postdelete after actually deleting a row record the fact that the instance no longer exists on the database needed for identity column key generation and remove it from the session cache
Hib,negative,a newly instantiated collection ca not have orphans
Hib,negative,do not hold the jbc node lock throughout the tx as that prevents reads and other updates
Hib,negative,check the version unsaved value if appropriate
Hib,negative,create the sessionfactory from hibernate cfg xml
Hib,negative,handle orphaned entities
Hib,negative,ignore
Hib,negative,check the id unsaved value
Hib,negative,if we get here it is possible that we have a proxy  in the way  of the merge map resolution note decided to put this here rather than in the above loop as i was nervous about the performance of the loop in loop especially considering this is far more likely the  edge case 
Hib,negative,check to see if it is in the second level cache
Hib,negative,custom sql would be better if these were private
Hib,negative,
Hib,negative,our column span is the number of columns in the pk
Hib,negative,for property references generate tablealias columnname as projectionalias
Hib,negative,in case we were deserialized in a different jvm look for an instance with the same name alternatively we could do an actual jndi lookup here
Hib,negative,
Hib,negative,key
Hib,negative,force immediate execution of the insert
Hib,negative,general purpose parameters
Hib,negative,entities
Hib,negative,constructors
Hib,negative,loaded entity instances by entityuniquekey
Hib,negative,allow any identifier quoted with backtick only recognizes identifiers beginning with a letter
Hib,negative,collections
Hib,negative,configurable implementation
Hib,negative,identity map of entityentry instances by the entity instance
Hib,negative,write html footer
Hib,negative,entity proxies by entitykey
Hib,negative,delete does cascade to uninitialized collections
Hib,negative,snapshots of current database state for entities that have not been loaded
Hib,negative,nativesql collect key column and auto aliases
Hib,negative,identity map of array holder arrayholder instances by the array instance
Hib,negative,unquotedkeycolumnnames stringhelper unquote keycolumnaliases
Hib,negative,cannot occur
Hib,negative,do not need to lock the cache here since if someone else inserted the same pk first the insert would fail
Hib,negative,cannot occur
Hib,negative,this is not strictly true we actually just need to make sure that it is ordered by root entity pk and that that order by comes before any non root entity ordering
Hib,negative,try get
Hib,negative,pass control along to the rest of the processing chain
Hib,negative,set of entitykeys of deleted objects
Hib,negative,all this only really needs to consider properties of this class not its subclasses but since we are reusing code used for sequential selects we use the subclass closure
Hib,negative,a list of collection wrappers that were instantiating during result set processing that we will need to initialize at the end of the query
Hib,negative,protected void initpropertypaths final string path final type type final string columns final string formulatemplates final mapping factory throws mappingexception addformulapropertypath path type formulatemplates initpropertypaths path type columns formulatemplates factory
Hib,negative,downgrade locks
Hib,negative,column model gettable getprimarykey getcolumniterator next getname
Hib,negative,do nothing
Hib,negative,deserialize
Hib,negative,do nothing
Hib,negative,actually the semantics of the next three are really bag note that unlike objects collection insertions updates deletions are not really remembered between flushes we just re use the same lists for convenience
Hib,negative,public boolean isshowsqlenabled return showsql public boolean isformatsqlenabled return formatsql
Hib,negative,with two deep subqueries the same alias would get generated for both using the old method criteriaquery generatesqlalias so that is now used as a fallback if the main criteria alias is not set
Hib,negative,array null ? templist size
Hib,negative,sort the updates by pk
Hib,negative,should be safe to only ever expect entitypersister references here
Hib,negative,optimize the hash size to eliminate a rehash
Hib,negative,unwrap the object
Hib,negative,impl note takes advantage of the fact that an escpaed single quote embedded within a quote block can really be handled as two seperate quote blocks for the purposes of this method
Hib,negative,again ccs did not have such a concept but a reasonable proximity is to clear the cache after transaction as long as the underlying cache is not jta aware
Hib,negative,the entity associated with the current action
Hib,negative,this page intentionally left blank
Hib,negative,unfortunately this stuff ca not be cached because it is per invocation not constant for the querytranslator instance
Hib,negative,initialize unwrap the object
Hib,negative,sequence support
Hib,negative,do not do anything
Hib,negative,we ca not batch joined inserts especially not if it is an identity insert nor can we batch statements where the expectation is based on an output param
Hib,negative,
Hib,negative,unfortunately this stuff ca not be cached because it is per invocation not constant for the querytranslator instance
Hib,negative,return the proxied object
Hib,negative,else no collection element but also no owner
Hib,negative,ignore
Hib,negative,we have the form trim trimsource so we trim leading and trailing spaces early exit
Hib,negative,overwrite old proxy
Hib,negative,the mru cache used to keep hard references to the most recently used query plans note lru here is a bit of a misnomer it indicates that lru entries are removed the actual kept entries are the mru entries
Hib,negative,early exit
Hib,negative,handles things like a and b or c a and b or c not a and not b not a and b x between y and z overloaded and x in a b c overloaded brackets not not a a is not null overloaded not etc and expressions like foo bar maps to foo id bar id foo bar  foo  maps to foo bar  foo  foo bar baz maps to foo bar bar id and bar baz foo bar baz maps to bar baz and foo bar bar id foo bar baz a b c maps to bar baz b c and foo bar bar id and a b b id foo bar baz a b c maps to bar baz b c and foo bar bar id and a b b id foo bar baz maps to bar baz and foo bar bar id
Hib,negative,or should it actually throw an exception ?
Hib,negative,both many to one and one to one are represented as a property entitypersister is relying on this value to determine lazy fetch groups in terms of field level interception so we need to make sure that we return true here for the case of many to one and one to one with lazy no proxy impl note lazy no proxy currently forces both lazy and unwrap to be set to true the other case we are extremely interested in here is that of lazy proxy where lazy is set to true but unwrap is set to false thus we use both here under the assumption that this return is really only ever used during persister construction to determine the lazy property field fetch groupings if that assertion changes then this check needs to change as well partially this is an issue with the overloading of the term lazy here
Hib,negative,the property is a component
Hib,negative,the ids are fully resolved so compare them with isdirty not ismodified
Hib,negative,cant instantiate
Hib,negative,queryjoinfragment join q createjoinfragment usethetastylejoin
Hib,negative,if it is a property of an embedded component invoke on the identifier
Hib,negative,subclasses
Hib,negative,otherwise
Hib,negative,starts with the name of a mapped class new style
Hib,negative,treat it just like a new collection
Hib,negative,we must return a valid rdms rsa command from this method to prevent rdms rsa from issuing error 
Hib,negative,skip finalize methods
Hib,negative,return the fully resolved identifier value but do not resolve to the actual referenced entity instance note the owner of the association is not really the owner of the id
Hib,negative,do this work only at the very highest level of the load do not let this method be called recursively
Hib,negative,public static jdbcexception newjdbcexception string string sqlexception root string sql string string sql log error string root logexceptions root return new jdbcexception string root sql public static jdbcexception newjdbcexception string string sqlexception root log error string root logexceptions root return new jdbcexception string root
Hib,negative,note that each iteration of the loop may add new elements
Hib,negative,if we know there is exactly row we can skip it would be great if we could always skip this it is a problem for key many to one
Hib,negative,this can never happen because this rule will always eliminate the child not case not return x getfirstchild not not x x
Hib,negative,we need to obtain the lock before any actions are executed since this may be an inverse true bidirectional association and it is one of the earlier entity actions which actually updates the database this action is resposible for second level cache invalidation only
Hib,negative,hhh make sure the callback gets cleared otherwise the instance stays in a static thread local
Hib,negative,no point doing this if none was requested
Hib,negative,while constructor is running
Hib,negative,the keyword used to specify a nullable column
Hib,negative,while constructor is running
Hib,negative,there is probably a row there so try to update if no rows were updated we will find out
Hib,negative,note interface is assumed to already contain hibernateproxy class
Hib,negative,do nothing to avoid a lazy property initialization
Hib,negative,interfaces arguments
Hib,negative,not called at runtime so does not matter if its slow
Hib,negative,todo
Hib,negative,chop off the rest of the tree
Hib,negative,get the caller
Hib,negative,prefer re generation of identity
Hib,negative,get the caller principals
Hib,negative,refresh does not cascade to uninitialized collections
Hib,negative,private static final alias default alias new alias null
Hib,negative,do nothing
Hib,negative,public boolean isnonexistant entitykey key return nonexistantentitykeys contains key
Hib,negative,generate id select fragment and then property select fragment for each expression just like generateselectfragments
Hib,negative,public boolean isnonexistant entityuniquekey key return nonexistententityuniquekeys contains key
Hib,negative,special case this is the leaf of the containment graph even though not immutable
Hib,negative,iterate all the entities currently associated with the persistence context
Hib,negative,according to both the ansi sql and jpa specs trim takes a variable number of parameters between and at least one paramer trimsource is required from the sql spec trim function trim left paren trim operands right paren trim operands trim specification trim character from trim source trim specification leading trailing both if trim specification is omitted both is assumed if trim character is omitted space is assumed
Hib,negative,does this entity entry pertain to the entity persister in which we are interested owner ?
Hib,negative,prepare persisters and link them up with their cache region access strategy
Hib,negative,check if the managed object is the parent
Hib,negative,allows various loaders ok mainly the queryloader to check whether scrolling of their result set should be allowed by default it is allowed
Hib,negative,otherwise the proxy was pruned during the serialization process
Hib,negative,does not handle arrays thats ok cos they ca not be lazy or newly instantiated collections so we can do the cast
Hib,negative,adds remove as a sort of alias for delete
Hib,negative,unquotedidentifiercolumnname identifiercolumnalias
Hib,negative,return lhspersister getsubclasspropertycolumnnames property
Hib,negative,saves updates do not cascade to uninitialized collections
Hib,negative,early exit
Hib,negative,create our own copy of the user supplied tuplizer impl map
Hib,negative,if the identifier is quoted remove the quotes
Hib,negative,we can do the cast since orphan delete does not apply to newly instantiated collections arrays we ca not track orphans for detached arrays
Hib,negative,truncate the identifier to the max alias length less the suffix length
Hib,negative,
Hib,negative,full joins are not supported yet
Hib,negative,you may still have other resultsets or update counts left to process here but you ca not do it now or the resultset you just got will be closed
Hib,negative,null is not considered the same type as integer non nls non nls 
Hib,negative,properly handle property ref based associations
Hib,negative,the outerjoinsafterwhere needs to come before where clause to properly handle dynamic filters
Hib,negative,determine the id getter and setter methods from the proxy interface if any determine all interfaces needed by the resulting proxy
Hib,negative,non nls 
Hib,negative,add another inner nested select add the main query close off the inner nested select
Hib,negative,non nls 
Hib,negative,origin adddestination destination this was the cause of hhh origin settype from fragment set the parent node type so that the ast is properly formed the destination node will have all the from text the parent node is a collection join too voodoo see joinprocessor
Hib,negative,non nls 
Hib,negative,then handle any user defined entity modes
Hib,negative,non nls 
Hib,negative,overridden informational metadata
Hib,negative,strip off any leading  and  token
Hib,negative,then the pojo tuplizer using the dynamic map tuplizer if no pojo representation is available
Hib,negative,if the condition is not already there
Hib,negative,this has been shown to happen occasionally in rare cases when using a transaction manager transaction timeout where the timeout calls back through hibernate is registered transaction synchronization on a separate reaping thread in cases where that reaping thread executes through this block at the same time the main application thread does we can get into situations where these cmes occur and though it is not allowed per se the end result without handling it specifically is infinite looping so here we simply break the loop
Hib,negative,dontspace add  
Hib,negative,public componentmetamodel component component sessionfactoryimplementor sessionfactory
Hib,negative,for mysql
Hib,negative,detect discriminator values
Hib,negative,set a custom entity resolver this entity resolver must be set before addxxx misc call default value is link org hibernate util dtdentityresolver param entityresolver entity resolver to use
Hib,negative,handle any filters applied to this collection
Hib,negative,handle a property ref
Hib,negative,if we could not register a synchronization do the before after completion callbacks ourself but we need to let jdbccontext know that this is what we are going to do so it does not keep trying to register synchronizations
Hib,negative,hashmap columnsunique new hashmap
Hib,negative,then the pojo tuplizer using the dynamic map tuplizer if no pojo representation is available
Hib,negative,null caused some problems
Hib,negative,two conditions where we need to transform this to a theta join syntax  elem  is the root from element in correlated subqueries the dotnode usethetastyleimplicitjoins has been set to true and  elem  represents an implicit join
Hib,negative,package
Hib,negative,cascade the refresh prior to refreshing this entity
Hib,negative,not sure if this would ever be null but wanted to be careful
Hib,negative,impl note takes advantage of the fact that an escpaed single quote embedded within a quote block can really be handled as two seperate quote blocks for the purposes of this method
Hib,negative,even on inverse true
Hib,negative,properties
Hib,negative,package
Hib,negative,we need to dirty check many to ones with not found ignore in order to update the cache not the database since in this case a null entity reference can lose information
Hib,negative,package
Hib,negative,register hibernate types for default use in scalar sqlquery type auto detection
Hib,negative,if true then execute db updates otherwise just generate and display updates
Hib,negative,sqlfunction implementation
Hib,negative,we only release the connection
Hib,negative,we only check the version when upgrading lock modes
Hib,negative,deprecated option
Hib,negative,only carry on if the method has no parameters
Hib,negative,nativesqlqueryreturn
Hib,negative,woops we got an instance of another class hierarchy branch
Hib,negative,composite id
Hib,negative,create an outerjoingenerator for this dialect
Hib,negative,if an exception occurs during flush user must call rollback
Hib,negative,string
Hib,negative,actually this last test is probably unnecessary since beforecompletion does not get called during rollback
Hib,negative,we need to step through the rows one row at a time slow
Hib,negative,final boolean forcecacherefresh
Hib,negative,lock acquisition support
Hib,negative,create an dotnode ast for the path and resolve it
Hib,negative,its already loaded so do not need to hydrate it
Hib,negative,if an exception occurs during flush user must call rollback
Hib,negative,orphans should be deleted during delete
Hib,negative,swallow it and continue to roll back jta transaction
Hib,negative,here we have two possibilities the property name matches the explicitly identifier property name the property name matches the implicit  id  property name
Hib,negative,so the transaction is already rolled back by jta spec
Hib,negative,we found a collection element in the result set
Hib,negative,this method is a noop if there is a synchronization
Hib,negative,register the standard dialect resolver
Hib,negative,why is all others non final ?
Hib,negative,even though we might find a pre existing element by join path we may not be able to reuse it
Hib,negative,hella important optimization
Hib,negative,include the discriminator and class level where but not filters
Hib,negative,return that type equals type equalshelper equals that value value
Hib,negative,null child could occur for no from clause in a filter
Hib,negative,the  from element  that the property is in
Hib,negative,since the result set cursor is always left at the first physical row after the last processed we need to jump back one position to get the key value we are interested in skipping
Hib,negative,websphere however is not a sane jee jta container
Hib,negative,loop through all the associated entities and make sure they have been processed before the latest batch associated with this entity type
Hib,negative,for sane jee jta containers the transaction itself functions as its identifier
Hib,negative,first try to find a matching constructor accepting a violatedconstraintnameextracter param
Hib,negative,swallow the transaction was finished
Hib,negative,will be ignored using the existing entry instead
Hib,negative, seconds
Hib,negative,this property belongs to the table and it is not specifically excluded from optimistic locking by optimistic lock false
Hib,negative,do not hold a transactional lock for this
Hib,negative,some collections are not lazy
Hib,negative,fix up the resident flag
Hib,negative,does the limit clause come at the start of the select statement rather than at the end ?
Hib,negative,all aliastoentitymapresulttransformer are considered equal
Hib,negative,the following two lines were added to ensure that this params is not null which can happen with two deep nested subqueries
Hib,negative,set the attributes of the property reference expression
Hib,negative,the current batch number is the latest batch for this entity type
Hib,negative,take a snapshot
Hib,negative,we can inner join to superclass tables the row must be there we can never inner join to subclass tables
Hib,negative,never evict this node
Hib,negative,does the collection referenced by this fromelement specify an order by attribute ? if so attach it to the query is order by
Hib,negative,create the join element under the from element
Hib,negative,for merging of versioned entities we consider the version having been changed only when the two version values are different and the target actually represents database state this second condition is a special case which allows an entity to be merged during the same transaction though during a seperate operation in which it was originally persisted saved
Hib,negative,moved here from selectclause jsd
Hib,negative,pre determine and cache the hashcode
Hib,negative,
Hib,negative,not between a b not between a b
Hib,negative,make sure the root node for the region exists and has a dataversion that never complains
Hib,negative,ps close just close it do not try to return it to the pool note early exit
Hib,negative,map of entitymode tuplizer
Hib,negative,now write the values of fields onto the prepared statement
Hib,negative,this is a virtual id property
Hib,negative,need to use the identifier type of the collection owner since the incoming is value is actually the owner is id using the collection is key type causes problems with property ref keys
Hib,negative,create our own copy of the user supplied tuplizer impl map
Hib,negative,the current timestamp is more accurate but only known to be supported in sql server and later i e sybase not known to support it at all
Hib,negative,this one needed only for guessentitymode
Hib,negative,will check current level if some of them are not null or sublevels if they exist
Hib,negative,build the dynamic map tuplizer
Hib,negative,pointbase has no known variation of a select for update syntax
Hib,negative,then dom j tuplizer if dom j representation is available
Hib,negative,see if the entity is already bound to this session if not look at the entity identifier and assume that the entity is persistent if the id is not unsaved that is we rely on foreign keys to keep database integrity
Hib,negative,do the work
Hib,negative,if its an uninitialized proxy it ca not be transient
Hib,negative,we  ve been here before
Hib,negative,return the id so we can use it to reset the proxy id return result
Hib,negative,build the dynamic map tuplizer
Hib,negative,return false here as most databases do not properly support this construct
Hib,negative,do the work
Hib,negative,stuff that is persister centric and or entityinfo centric
Hib,negative,put the standard tuplizers into the tuplizer map first
Hib,negative,hit the database after checking the session cache for a snapshot
Hib,negative,found a ctor but it was not publicly accessible so try to request accessibility
Hib,negative,our parent is another dot node meaning we are being further dereferenced thus we need to generate a join unless the parent refers to the associated entity is pk because  our  table would know the fk
Hib,negative,private final sessionfactoryimplementor sessionfactory
Hib,negative,search for collections by reachability updating their role we do not want to touch collections reachable from a deleted object
Hib,negative,cached for efficiency
Hib,negative,sql server just returns automatically
Hib,negative,this sessionfactory sessionfactory
Hib,negative,table support
Hib,negative,it was not embedded so the argument is just an id
Hib,negative,we have specialized case of a detached entity from the perspective of the merge operation specifically we have an incoming entity instance which has a corresponding entry in the current persistence context but registered under a different entity instance
Hib,negative,then dom j tuplizer if dom j representation is available
Hib,negative,where fragment must be empty
Hib,negative,or its key changed
Hib,negative,int parameterstart getwalker getnumberofparametersinsetclause list allparams getidselectparameterspecifications iterator whereparams allparams sublist parameterstart allparams size iterator
Hib,negative,put the standard tuplizers into the tuplizer map first
Hib,negative,miscellaneous support
Hib,negative,we will need to remove ye olde entries
Hib,negative,add the current fragment to the theta joins node
Hib,negative,force initialize
Hib,negative,lock does not cascade to uninitialized collections
Hib,negative,return currentid
Hib,negative,unquotedidentifiercolumnname null
Hib,negative,reset the id
Hib,negative,addinitializedcollection collection persister id
Hib,negative,collectionpropertymapping processes everything except  index 
Hib,negative,if it is an uninitialized proxy pointing with this session then when it is accessed the underlying instance will be contained
Hib,negative,reset the version
Hib,negative,note this simply constructs a raw sql token representing the where fragment and injects this into the tree this works however it is probably not the best long term solution at some point we probably want to apply an additional grammar to properly tokenize this where fragment into constituent parts focused on the operators embedded within the fragment
Hib,negative,the default is to simply not lazy fetch properties for now
Hib,negative,aliases for identifier alias id skip if the entity defines a non id property named  id 
Hib,negative,else if it is elements changed
Hib,negative,this assumes you will want to ignore any update counts
Hib,negative,attributes maintained between flush cycles
Hib,negative,now rebuild the insertions list there is a batch for each entry in the name list
Hib,negative,should be safe to only ever expect entitypersister references here
Hib,negative,if the original is a persistentcollection and that original was not flagged as dirty then reset the target is dirty flag here after the copy operation p one thing to be careful of here is a bare original collection in which case we should never ever ever reset the dirty flag on the target because we simply do not know
Hib,negative,session start post flush persistent state
Hib,negative,temporary
Hib,negative,allow the collectionsnapshot to be serialized
Hib,negative,first break down the returns into maps keyed by alias so that role returns can be more easily resolved to their owners
Hib,negative,add the second join the one that ends in the destination table
Hib,negative,generate an d array of column names the first dimension is parallel with the return types array the second dimension is the list of column names for each type
Hib,negative,attributes used only during flush cycle
Hib,negative,create sql token nodes for the columns
Hib,negative,current means the reference that was found during flush
Hib,negative,rdms has no known variation of a select for update syntax
Hib,negative,ignore this row of results note the early exit
Hib,negative,not final static to avoid possible classcast exceptions if using different oracle drivers
Hib,negative,found a ctor but it was not publicly accessible so try to request accessibility
Hib,negative,add the new node to the map so that we do not create it twice
Hib,negative,return getfactory getsettings getbytecodeprovider getproxyfactoryfactory buildproxyfactory
Hib,negative,oracle driver reports to support getgeneratedkeys but they only support the version taking an array of the names of the columns to be returned via its returning clause no other driver seems to support this overloaded version
Hib,negative,not final because proxy factory creation can fail
Hib,negative,register the fromelement with the from clause now that we have the names and aliases
Hib,negative,superclass entity name
Hib,negative,first allow the actual type to control the return value the actual underlying sqltype could actually be different
Hib,negative,temporary
Hib,negative,cascade save to collections after the collection owner was saved
Hib,negative,
Hib,negative,pass along our initial embedded parameter node s to the first generated sql fragment so that it can be handled later for parameter binding
Hib,negative,loaded means the reference that is consistent with the current database state
Hib,negative,cache the actual id of the object not the value of the property ref which might not be initialized
Hib,negative,init the aliases after initing the constructornode
Hib,negative,you may still have other resultsets or update counts left to process here but you ca not do it now or the resultset you just got will be closed
Hib,negative,temporary
Hib,negative,multi param string dialect functions
Hib,negative,during flush we navigate the object graph to collections and decide what to do with them
Hib,negative,save operations
Hib,negative,collection cleardirty
Hib,negative,the  from element  that represents the elements of the collection
Hib,negative,legacy behavior with no abstract attribute specified
Hib,negative,constructors are always considered scalar results
Hib,negative,get ready to start adding nodes
Hib,negative,use the id column alias
Hib,negative,collection types
Hib,negative, note that this is also true of datetime param
Hib,negative,collection cleardirty
Hib,negative,we do not need to worry about existing version being uninitialized because this block is not called by a re entrant load re entrant loads always have lock mode none
Hib,negative,note this affects the return value
Hib,negative,istransactioncallbackregistered denotes whether any hibernate transaction has registered as a callback against this jdbccontext only one such callback is allowed directly serializing this value causes problems with jdbctransaction or really any transaction impl where the callback is local to the transaction instance itself since that transaction is not serialized along with the jdbccontext thus we handle that fact here explicitly
Hib,negative,note evict operates locally only i e does not propogate to any other nodes in the potential cluster this is exactly what is needed when we destroy here destroy is used as part of the process of shutting down a sessionfactory thus these removals should not be propogated
Hib,negative,generate the inner join the elements need to be joined to the collection they are in
Hib,negative,otherwise perform a deep equivalence check
Hib,negative,might happen with a managed connection
Hib,negative,need to account for allowable within the variant
Hib,negative,for expected parameter type injection we expect that the lhs represents some form of property ref and that the children of the in list represent one or more params
Hib,negative,if there is no where node make one
Hib,negative,we found it in the temp pc should indicate we are in the midst of processing a result set containing eager fetches via join fetch
Hib,negative,add the type to the list of returned sqlresulttypes
Hib,negative,overridden informational metadata
Hib,negative,create one
Hib,negative,persists do not cascade to uninitialized collections
Hib,negative,lobs cannot be compared
Hib,negative,this property belongs to the table and it is not specifically excluded from optimistic locking by optimistic lock false
Hib,negative,blobs are ignored by merge
Hib,negative,hhh implied joins in a subselect where clause the destination needs to be added to the destination is from clause not sure if this is will fix everything but it works
Hib,negative,value is the entity name
Hib,negative,handle the assumed valid cases the only valid datetime addition synatx is one or the other is a datetime but not both
Hib,negative,optimization
Hib,negative,the map of batch numbers to entityinsertaction lists
Hib,negative,optimization optimization
Hib,negative,we do not need to worry about any condition in the on clause here tofromfragmentstring since anything in the on condition is already applied to the whole query
Hib,negative,re snapshot
Hib,negative,the difficulty here is exactly what do we update in order to force the version to be incremented in the db
Hib,negative,for convenience to save some lookups
Hib,negative,regions can get instantiated in the course of normal work e g a named query region will be created the first time the query is executed so suspend any ongoing tx
Hib,negative,note this is not updated when properties are fetched lazily
Hib,negative,an ident node can represent an index expression if the ident represents a naked property ref note this makes the assumption which is currently the case in the hql sql grammar that the ident is first resolved itself addrexpr resolve the other option if that changes is to call resolve from here but it is currently un needed overhead
Hib,negative,early exit
Hib,negative,public list getcollectionaliases return collectionaliases public list getcollectionowners return collectionowners public list getcollectionowneraliases return collectionowneraliases public list getcollectionpersisters return collectionpersisters public map getalias persister return alias persister public boolean iscollectioninitializer return iscollectioninitializer public list getpersisters return persisters public map getalias owneralias return alias owneralias public list getscalartypes return scalartypes public list getscalarcolumnaliases return scalarcolumnaliases public list getpropertyresults return propertyresults public list getcollectionpropertyresults return collectionresults public map getalias return return alias return
Hib,negative,todo
Hib,negative,this solution would allow us to eliminate the owner arg to disassemble but what if the collection was null and then later had elements added ? seems unsafe session getpersistencecontext getcollectionentry persistentcollection value getkey
Hib,negative,xml is the entity name
Hib,negative,named query parameter
Hib,negative,tolerates nulls
Hib,negative,check to see if our proppath actually represents a property on the persister
Hib,negative,add the token to the ast
Hib,negative,use the table fromelement and the property name to get the array of column names
Hib,negative,set up the cache factory
Hib,negative,we need to strip off the embedded parens so that sql gen does not double these up
Hib,negative,memory optimization
Hib,negative,then handle any user defined entity modes
Hib,negative,sqlresulttypelist
Hib,negative,if this is an implied join in a from element then use the impled join type which is part of the tree parser is state set by the gramamar actions
Hib,negative,metatype is assumed to be single column type
Hib,negative,end unit of work
Hib,negative,row id
Hib,negative,multitables
Hib,negative,final list extendsqueue
Hib,negative,make sure jbc does not look one up
Hib,negative,get all the select expressions that we just generated and render the select
Hib,negative,
Hib,negative,visit width first then depth
Hib,negative,if the uresolved property path is not set yet just use the property name
Hib,negative,look through the fromelement is children to find any collections of values that should be fetched
Hib,negative,identifier commalist
Hib,negative,return associationtype foreign key to parent this is better but causes a transient object exception
Hib,negative,collections of values
Hib,negative,copied from session
Hib,negative,for an explicit many to many relationship add a second join from the intermediate many to many table to the destination table also make sure that the from element is idea of the destination is the destination table
Hib,negative,this should not happen since the dtd prevents it
Hib,negative,need to parse off the column qualifiers this is assuming which is true as of now that this is only used from update and delete hql statement parsing
Hib,negative,the current join represents the join between a many to many association table and its target table here we need to apply any additional filters defined specifically on the many to many
Hib,negative,if the from element represents a join fragment and it is a theta style join convert its type from join fragment to from fragment
Hib,negative,check basic level one nullablilty
Hib,negative,add a zero or quite low timeout option so we do not block ignore any timeoutexception basically we forego caching the query result in order to avoid blocking reads are done with suspended tx so they should not hold the lock for long not caching the query result is ok since any subsequent read will just see the old result with its out of date timestamp that result will be discarded and the db query performed again
Hib,negative,values is not null and is checkable we will look deeper
Hib,negative,possibly handle something parameters for the query ?
Hib,negative,for non null args check for components and elements containing components
Hib,negative,if we want to handle it bidirectional and detached we also need to load this collection with an eager outer join fetch this time with criteria and not hql
Hib,negative,cache the hashcode
Hib,negative,public propertyprojection project return projections property getpropertyname
Hib,negative,persistent collections may have components
Hib,negative,we have the jbcwritemutex so no other local thread will be trying to write this key it is possible here some remote thread has come in and changed the values again but since we are reading the values to write to jbc right now we know we are writing the latest values i e we do not assume that what we cached in entry update above is what we should write to jbc now our write could be redundant i e we are writing what some remote thread just came in an wrote there is a chance that yet another remote thread will update us and we will then overwrite that later data in jbc but all remote nodes will ignore that change in their localcache the only place it will live will be in jbc where it can only effect the initial state transfer values on newly joined nodes i e populatelocalcache
Hib,negative,test out the optimizer
Hib,negative,registercolumntype types varchar mediumtext
Hib,negative,ident might be the name of a class
Hib,negative,here we do not want to suspend the tx if we do we might be caching query results that reflect uncommitted changes no tx no wl on cache node so other threads can prematurely see those query results no tx immediate replication more overhead plus we spread issue above around the cluster
Hib,negative,todo
Hib,negative,for regression testing against output from the old parser found it easiest to simply reorder the fromelements here into ascending order in terms of injecting them into the resulting sql ast in orders relative to those expected by the old parser this is definitely another of those only needed for regression purposes the syntheticandfactory then simply injects them as it encounters them
Hib,negative,st settimestamp index new timestamp cal gettimeinmillis cal jdk only
Hib,negative,arbitrary on clause ignored
Hib,negative,st setdate index new date cal gettimeinmillis cal jdk only
Hib,negative,from javax naming referenceable
Hib,negative,both are timestamps
Hib,negative,first collect all of the select expressions note this must be done before invoking setscalarcolumntext because setscalarcolumntext changes the ast
Hib,negative,at least one is a plain old date
Hib,negative,swallow it the transaction was successful or successfully rolled back
Hib,negative,check for all components values in the collection
Hib,negative,after all persisters and named queries are registered
Hib,negative,do the test
Hib,negative,limit support ala top
Hib,negative,if close is called guarantee unbind
Hib,negative,or byte or text ? or money
Hib,negative,noop
Hib,negative,implied dotnode usethetastyleimplicitjoins
Hib,negative,if the corresponding sql value is null the reader we got is null as well
Hib,negative,if there is no data type for this node and we  re at the end of the path top most dot node then this might be a java constant
Hib,negative,fetch reader content up to the end and put characters in a stringbuffer
Hib,negative,the loop ensures atomicity of the select update even for no transaction or read committed isolation level
Hib,negative,return stringbuffer content as a large string
Hib,negative,the where clause was added to eliminate this statement from brute force searches
Hib,negative,or types longvarchar ?
Hib,negative,overridden informational metadata
Hib,negative,todo
Hib,negative,we ignore minimalputoverride jbosscache putforexternalread is already about as minimal as we can get it will promptly return if it discovers that the node we want to write to already exists
Hib,negative,forcefully remove leading ands from where fragments the grammar will handle adding them
Hib,negative,for non arrays we do not need to know the element class elementtype returnedclass
Hib,negative,chop off the rest of the tree
Hib,negative,grab its state from the resultset and keep it in the session but do not yet initialize the object itself note that we acquire lockmode read even if it was not requested
Hib,negative,different nullability rules for pk fk
Hib,negative,if the types report logical equivalence return true
Hib,negative,cache this
Hib,negative,for a subquery the alias to use depends on a few things we already know this is not an overall select if this from element represents a correlation to the outer most query a if the outer query represents a multi table persister we need to use the given alias in anticipation of one of the multi table executors being used as this subquery will actually be used in the id select phase of that multi table executor b otherwise we need to use the persister is table name as the column qualification otherwise not correlated use the given alias
Hib,negative,only really need new array during semiresolve
Hib,negative,classic translator does not support collection of ordinal param metadata
Hib,negative,unwrap it
Hib,negative,cache the hashcode
Hib,negative,an unfetched association can only point to an entity that already exists in the db
Hib,negative,here we work under the following assumptions valid cases datetime something other than datetime always results in a datetime db will catch invalid conversions datetime datetime always results in a double datetime something other than datetime always results in a datetime db will catch invalid conversions invalid cases datetime datetime something other than datetime datetime datetime any type datetime any type any type datetime doing so allows us to properly handle parameters as either the left or right side here in the majority of cases
Hib,negative,let the interceptor inspect the instance to decide
Hib,negative,the types represented in the sql result set return the types represented in the sql result set
Hib,negative,let the persister inspect the instance to decide
Hib,negative,the cascadingaction contract
Hib,negative,todo
Hib,negative,ddl support
Hib,negative,create a new filters node as a parent of all filters
Hib,negative,if there is no tm configured we will not be able to access the javax transaction transaction object in order to register a synch anyway
Hib,negative,
Hib,negative,establish the region root node with a non locking data version
Hib,negative,public object instantiate object parent sessionimplementor session throws hibernateexception
Hib,negative,nothing to do
Hib,negative,nothing to do
Hib,negative,we use the assumed value if there is one to avoid hitting the database
Hib,negative,context entity identifier returns null explicitly if the entity is not associated with the persistence context so make some deeper checks
Hib,negative,int count 
Hib,negative,putfield new value of the field
Hib,negative,lobs cannot be compared
Hib,negative,not really necessary i guess
Hib,negative,clobs are ignored by merge operation
Hib,negative,the first key found after the given key
Hib,negative,collections cannot be compared
Hib,negative,remember the uk value
Hib,negative,noop
Hib,negative,processcollectionproperty token q getcollectionpersister collectionrole collectionname
Hib,negative,we must use the remembered uk value since it is not available from the entityentry during assembly
Hib,negative,collections do not dirty an unversioned parent entity
Hib,negative,return false
Hib,negative,this just handles a particular case of component projection perhaps get rid of it and throw an exception
Hib,negative,note we avoid joining to the next table if the named property is just the foreign key value
Hib,negative,the key is the owning entity itself so get the id from the key
Hib,negative,checkforend false
Hib,negative,ignore subselect keywords
Hib,negative,copy elements into newly empty target collection
Hib,negative,end of array start filling again from start
Hib,negative,for a null target or a target which is the same as the original we need to put the merged elements in a new collection
Hib,negative,we ran out of keys to try
Hib,negative,by default just use an unanticipated capacity since we do not know how to extract the capacity to use from original here
Hib,negative,the first id found after the given id
Hib,negative,we ran out of ids to try
Hib,negative,discriminator
Hib,negative,get the elements back into the target making sure to handle dirty flag
Hib,negative,check if collection is currently being loaded
Hib,negative,check if it is already completely loaded but unowned
Hib,negative,initialize this collection
Hib,negative,todo
Hib,negative,create a new collection wrapper to be initialized later
Hib,negative,some jdbc drivers erroneously return an empty array here for a null db value
Hib,negative,cannot batch fetch by unique key property ref associations
Hib,negative,we already know current is not null
Hib,negative,the owner of the association is not the owner of the id
Hib,negative,constructors
Hib,negative,instance variables
Hib,negative,public methods
Hib,negative,compare the two maps for equality
Hib,negative,simple tests that require no synchronization
Hib,negative,sybase fail if we do not do that sigh
Hib,negative,stream closed in the finally
Hib,negative,release the jdk internal caches everytime to ensure this plays nicely with destroyable class loaders
Hib,negative,release the jdk internal caches everytime to ensure this plays nicely with destroyable class loaders
Hib,negative,try to pretty print it
Hib,negative,otherwise just dump it
Hib,negative,its an interface so we ca not really tell anything
Hib,negative,its an interface so we ca not really tell anything
Hib,negative,use default behavior
Hib,negative,note early return
Hib,negative,we want to be able to just use the defaults if jndi environment properties are not supplied so do not put null in anywhere
Hib,negative,clone
Hib,negative,serialize
Hib,negative,warning can cause a recursive calls proxy initialization
Hib,negative,stream closed in the finally
Hib,negative,static methods only hide constructor
Hib,negative,    character
Hib,negative,returnign null
Hib,negative,returnign null
Hib,negative,includes last    
Hib,negative, to include the following    
Hib,negative,first time we find match
Hib,negative,entitynames may now include slashes for the representations classname may be an inner class
Hib,negative,wrapped iterators
Hib,negative,index of current iterator in the wrapped iterators array
Hib,negative,the current iterator
Hib,negative,the last used iterator
Hib,negative,it was a boolean expression
Hib,negative,call this before any iterator method to make sure that the current iterator is not exhausted
Hib,negative,doable if needed
Hib,negative,set last used iterator here in case the user calls remove before calling hasnext or next although they should not
Hib,negative,peek ahead
Hib,negative,if we reach the end of the string w o finding the matching end that is an exception
Hib,negative,there were no queued additions and the role has a cache
Hib,negative,print page
Hib,negative,and this is not a forced initialization during flush
Hib,negative,we have a placeholder spin forward till we find the end
Hib,negative,make sure spinning forward did not put us past the end of the buffer
Hib,negative,first try to locate this resource through the current context classloader
Hib,negative,next try to locate this resource through this class is classloader
Hib,negative,next try to locate this resource through the system classloader
Hib,negative,anywhere else we should look ?
Hib,negative,would need an identityset for this
Hib,negative,arrays aslist does not do primitive arrays
Hib,negative,aload 
Hib,negative,faster ?
Hib,negative,pass the entity name if not a collection id
Hib,negative,right represents a joins originating from left or both right and left reprersent joins originating from the same fromelement
Hib,negative,the name of a class
Hib,negative,its the listener class name
Hib,negative,allow 
Hib,negative,default to element set if no elements specified
Hib,negative,look for the instance by uuid
Hib,negative,first lets determine whether to apply cglib or javassist based instrumentation
Hib,negative,make sure we do not override previous set values
Hib,negative,entirely optional
Hib,negative,its the listener instance or better be
Hib,negative,context unbind boundname
Hib,negative,readresolveobject
Hib,negative,cfg setproperty hibernate show sql true
Hib,negative,defensive convenience methods
Hib,negative,make sure you log the exception as it might be swallowed
Hib,negative,begin unit of work
Hib,negative,write html header
Hib,negative,handle actions
Hib,negative,start the session to be used for this request
Hib,negative,cleanup code
Hib,negative,make the session available to the session factory is current context
Hib,negative,remove session from current context
Hib,negative,eager fetch the collection so we can use it detached
Hib,negative,event anevent event session createcriteria event class setfetchmode participants fetchmode join add expression eq id eventid uniqueresult eager fetch the colleciton so we can use it detached
Hib,negative,end of first unit of work
Hib,negative,or bidirectional safety method setting both sides aperson addtoevent anevent
Hib,negative,begin second unit of work
Hib,negative,reattachment of aperson
Hib,negative,the getemailaddresses might trigger a lazy load of the collection
Hib,negative,we need our tm so get it now and avoid doing other work if there is a problem
Hib,negative,do not hold the jbc node lock throughout the tx as that prevents reads and other updates
Hib,negative,jbc put a version in the node when it created as part of some internal operation we are always newer but if the jbc version is something odd has happened
Hib,negative,not null if the isolation level has been specified in the configuration file otherwise it is left to the driver is default value
Hib,negative,configured outside of hibernate i e servlet container or java bean container already has proxool pools running and this provider is to just borrow one of these
Hib,negative,loading collection xrefs
Hib,negative,collection load contexts
Hib,negative,package
Hib,negative,the cache of the actual plans
Hib,negative,as is always optional for consistency with sql oql
Hib,negative,package
Hib,negative,assumes that types are all of span 
Hib,negative,process the new hql style where aliases are assigned after the class name or path expression ie using the as construction
Hib,negative,is a primitive type invokespecial
Hib,negative,start performing the updates
Hib,negative,array of primitive type do nothing
Hib,negative,jdbc params are based
Hib,negative,do not care
Hib,negative,on the inverse it makes sense that if a threadlocalsessioncontext bound session then gets deserialized to go ahead and re bind it to the threadlocalsessioncontext session map
Hib,negative,recognition code
Hib,negative,handle a path expression or class name that appears at the start in the new hql style or an alias that appears at the start in the old hql style
Hib,negative,important reuse the same event instances for performance
Hib,negative,do not care
Hib,negative,do not care about other param types here just those explicitly user defined
Hib,negative,handle is not not between not in
Hib,negative,jdbc params are based
Hib,negative,named parameter
Hib,negative,could be either an ordinal or jpa positional parameter
Hib,negative,strip the where
Hib,negative,a peek ahead showed this as an jpa positional parameter
Hib,negative,make sure this name is an integral
Hib,negative,at the very least cleanup the data
Hib,negative, seconds
Hib,negative,cannot be instantiated
Hib,negative,transfer an explicitly defined entity name handle the lazy attribute
Hib,negative,keep the behavior consistent even for boundary usages
Hib,negative,keep the behavior consistent even for boundary usages
Hib,negative,perform the actual work
Hib,negative,ignore
Hib,negative,do the failfast put outside the scope of the jta txn
Hib,negative,get meta is from joined subclass
Hib,negative,ignore
Hib,negative,parameters on the property mapping should override parameters in the typedef
Hib,negative,note special case default to join and non lazy for the second join of the many to many
Hib,negative,create the node initially with the param name so that it shows appropriately in the original text attribute
Hib,negative,dynamic insert
Hib,negative,so we clock over on the first invocation
Hib,negative,state
Hib,negative,finally handle the exception
Hib,negative,a detached collection that belonged to a different entity
Hib,negative,void setcomponenttuplizerfactory componenttuplizerfactory componenttuplizerfactory this componenttuplizerfactory componenttuplizerfactory
Hib,negative,element index id
Hib,negative,note that it might be better to iterate the snapshot but this is safe assuming the user implements equals properly as required by the set contract
Hib,negative,collections detect changes made via their public interface and mark themselves as dirty as a performance optimization
Hib,negative,saveorupdatecopy is deprecated
Hib,negative,set it
Hib,negative,collectionpersister should not be null but we do not want to throw an exception if it is null
Hib,negative,case multi token keywords group by and order by the next token lt should be  by  otherwise this is just an ident
Hib,negative,the default sqlexceptionconverter for all dialects is based on sqlstate since sqlerrorcode is extremely vendor specific specific dialects may override to return whatever is most appropriate for that vendor
Hib,negative,only necessary for postgre http anoncvs postgresql org cvsweb cgi pgsql doc src sgml ref create sequence sgml
Hib,negative,otherwise a null or brand new collection this will also inefficiently handle arrays which have no snapshot so we ca not do any better processarrayornewcollection collection type
Hib,negative,a detached collection that originally belonged to the same entity
Hib,negative,add the comment nest the main query in an outer select add the rownnumber bit into the outer query select list
Hib,negative,you may still have other resultsets or update counts left to process here but you ca not do it now or the resultset you just got will be closed
Hib,negative,note for object sql datatype mappings see configuration manager advanced sql system ddl datatype mappings tbd registercolumntype types binary binary changed jsl
Hib,negative,see if the second lookahed token can be an identifier
Hib,negative,case the current token is after from and before    
Hib,negative,do nothing
Hib,negative,trim end keyword string expression from string expression use hibernate implementation from is one of the parameters they pass in position ? registerfunction trim new sqlfunctiontemplate hibernate string trim ? ? from ? 
Hib,negative,whether this dialect has an identity clause added to the data type or a completely seperate identity data type
Hib,negative,eq null b is null b
Hib,negative,create nodes that track line and column number
Hib,negative,do nothing
Hib,negative,add not if it is negated
Hib,negative,eq a null is null a
Hib,negative,the path ast should be a dotnode and it should have been evaluated already
Hib,negative,force a substitution
Hib,negative,if if otherwise handle the error normally
Hib,negative,the database now holds a lock the object is flushed from the cache so release the soft lock
Hib,negative,now update the object has to be outside the main if block above because of collections
Hib,negative,named queries
Hib,negative,this is a situation where the entity id is assigned by a post insert generator and was saved outside the transaction forcing it to be delayed
Hib,negative,grab its state saved at deletion
Hib,negative,grab its current state
Hib,negative,this will throw an error if there is something wrong
Hib,negative,collection deletions are a special case since update can add deletions of collections not loaded by the session
Hib,negative,if the natural id is marked as non mutable it is not retrieved during a normal database snapshot operation
Hib,negative,watch out for a case where old is still referenced somewhere in the object graph which is a user error
Hib,negative,slice to get the columns for this component property
Hib,negative,schedule the update note that we intentionally do not pass in currentpersistentstate
Hib,negative,substitutes into values by side effect
Hib,negative,give the interceptor a chance to process property values if the properties were modified by the interceptor we need to set them back to the object
Hib,negative,not eq a b ne a b
Hib,negative,compare to cached state ignoring collections unless versioned
Hib,negative,if it was dirtied by a collection only
Hib,negative,check nullability but do not perform command execute we will use scheduled updates for that
Hib,negative,this  dot  expression now refers to the resulting from element
Hib,negative,not like a b not like a b
Hib,negative,the collectionentry isreached stuff is just to detect any silly users who set up circular or shared references between to collections
Hib,negative,detached collection wrappers that get found reattached during flush should not be ignored
Hib,negative,not is not null a b is null a b
Hib,negative,the unique property value represented here may or may not be serializable so we do an explicit check here in order to generate a better error message
Hib,negative,if the version of a newly instantiated object is not the same as the version seed value use that as the unsaved value
Hib,negative,ie we never have to null out a reference to an uninitialized proxy
Hib,negative,not not like a b like a b
Hib,negative,give the interceptor a chance to modify property values
Hib,negative,now we might need to recalculate the dirtyproperties array
Hib,negative,use the current version
Hib,negative,object loaded by update
Hib,negative,ignore this row the collection is in process of being loaded somewhere further up the stack
Hib,negative,entity load contexts currently not yet used
Hib,negative,dirty check against the usual snapshot of the entity
Hib,negative,this implementation is supposed to tolerate incorrect unsaved value mappings for the purpose of backward compatibility
Hib,negative,this implementation is supposed to tolerate incorrect unsaved value mappings for the purpose of backward compatibility
Hib,negative,wrap up any new collections directly referenced by the object or its components
Hib,negative,skip this check for composite ids relating to dom j entity mode alternatively we could add a check to make sure the incoming id value is an instance of element
Hib,negative,upgrade the lock if necessary lock result lockmode
Hib,negative,now any collections that are initialized inside this block do not get updated they are ignored until the next flush
Hib,negative,not ne a b eq a b
Hib,negative,we must clone embedded composite identifiers or we will get back the same instance that we pass in
Hib,negative,sub insertions should occur before containing insertion so try to do the callback now
Hib,negative,not le a b gt a b
Hib,negative,not ge a b lt a b
Hib,negative,not lt a b ge a b
Hib,negative,the entity is not associated with the session so try interceptor and unsaved value
Hib,negative,and the expected token type was an identifier then
Hib,negative,igndore it
Hib,negative,jsd the fix for hhh 
Hib,negative,if the token can tell us if it could be an identifier
Hib,negative,we are now at a new tree level
Hib,negative,dirty check against the database snapshot if possible necessary
Hib,negative,the interceptor handled the dirty checking
Hib,negative,use the delegate
Hib,negative,column simplevalue ic getindex getcolumniterator next setnullable false
Hib,negative, seconds
Hib,negative,get meta is from subclass
Hib,negative,evict operations
Hib,negative,ignore
Hib,negative,get the id from the object
Hib,negative,do the put outside the scope of the jta txn
Hib,negative,what is the version on the database ?
Hib,negative,hhh 
Hib,negative,stops flush being called multiple times if this method is recursively called
Hib,negative,will result in a sql update
Hib,negative,else do nothing do not even reassociate object
Hib,negative,no existing row do an insert
Hib,negative,inner classes moved here from sql gen g
Hib,negative,reference type
Hib,negative,use the delegate
Hib,negative,should be the first but just to be safe
Hib,negative,return a proxy if appropriate
Hib,negative,some filters affecting the collection are enabled on the session so do not do the put into the cache
Hib,negative,generate an explicit join for the root dot node the implied joins will be collected and passed up to the root dot node
Hib,negative,a session is considered to contain an entity only if the entity has an entry in the session is persistence context and the entry reports that the entity has not been removed
Hib,negative,and the token could be an identifer and the error is a mismatched token error
Hib,negative,if a where clause was specified in the update delete query use it to limit the returned ids here
Hib,negative,default implementation if this node has a data type and that data type is not an association then this is scalar
Hib,negative,resolve the lhs fully generate implicit joins pass in the property name so that the resolver can discover foreign key id properties
Hib,negative,if the propertytype is null and there is not a parent just stop now there was a problem resolving the node anyway
Hib,negative,we do not look for an existing join on the same path because it makes sense to join twice on the same collection role
Hib,negative,return new uninitialized proxy
Hib,negative,this object was already loaded
Hib,negative,entity was found in second level cache
Hib,negative,intializes result by side effect
Hib,negative,note max because first is zero based while max is not
Hib,negative,a shallow query is ok although technically there should be no fetching here
Hib,negative,delegate to the queryloader
Hib,negative,remember the parameters for the compilation
Hib,negative,package local methods for the queryloader delegate
Hib,negative,delegate to the queryloader
Hib,negative,double
Hib,negative,now done in entityidentityinsertaction persister setidentifier entity id source getentitymode
Hib,negative,double
Hib,negative,use the token as an identifier
Hib,negative,some statistics
Hib,negative,safe from concurrent modification because of how entrylist is implemented on identitymap
Hib,negative,transform the tree
Hib,negative,parse the query string into an hql ast
Hib,negative,we do not actually propogate antlrexceptions as a cause so log it here for diagnostic purposes
Hib,negative,so this needs to be safe from concurrent modification problems it is safe because of how identitymap implements entryset
Hib,negative,only needed during compilation phase
Hib,negative,update the status of the object and if necessary schedule an update
Hib,negative,schedule updates to collections
Hib,negative,we need to lock the collection caches before executing entity inserts updates in order to account for bidi associations
Hib,negative,the database has changed now so the subselect results need to be invalidated
Hib,negative,if the collection is dereferenced remove from the session cache iter remove does not work since the entryset is not backed by the set
Hib,negative,phase parse the hql into an ast
Hib,negative,key is an entity involved with the operation performed by the listener value is a flag indicating if the listener explicitly operates on the entity
Hib,negative,get a snapshot
Hib,negative,public final currency getcurrency int col throws hibernateexception return currency get col
Hib,negative,right represents a joins originating from left
Hib,negative,overriden to avoid system exit
Hib,negative,if the query is already compiled skip the compilation
Hib,negative,package private
Hib,negative,package private
Hib,negative,remember that ordinal parameters numbers are based
Hib,negative,overriden to avoid system exit
Hib,negative,all clear
Hib,negative,ignore the token class name parameter and use a specific token class
Hib,negative,this is a query and we are loading multiple instances of the same collection role
Hib,negative,early exit
Hib,negative,before any callbacks etc so subdeletions see that this deletion happened first
Hib,negative,ensures that containing deletions happen before sub deletions
Hib,negative,cascade delete to collections before the collection owner is deleted
Hib,negative,cascade delete to many to one after the parent was deleted
Hib,negative,if it is an initialized proxy let cascade handle it later on
Hib,negative,assign the requested id to the proxy before reassociating the proxy
Hib,negative,an uninitialized proxy noop do not even need to return an id since it is never a save
Hib,negative,initialize properties of the event
Hib,negative,return the id in the event object
Hib,negative,transient or deleted
Hib,negative,assume this is a newly instantiated transient object which should be saved rather than updated
Hib,negative,this is a transient object with existing persistent state not loaded by the session
Hib,negative,check two adjecent nodes at the top of the from clause tree
Hib,negative,cachedstate
Hib,negative,a detached collection
Hib,negative,if the collection belonged to a different entity clean up the existing state of the collection
Hib,negative,log debug calling onload
Hib,negative,early exit
Hib,negative,note performexecutions clears all collectionxxxxtion collections the collection actions in the session
Hib,negative,ie the entity came in from update
Hib,negative,we need to check even if it was not initialized because of delayed adds
Hib,negative,note early exit
Hib,negative,if template is null we just write the function out as it appears in the hql statement
Hib,negative,semantic action processing
Hib,negative,find any entities that are still transient after retry
Hib,negative,initialize sql nodes here
Hib,negative,early exit
Hib,negative,check the persistence context for an entry relating to this entity to be merged
Hib,negative,deleted
Hib,negative,set the unresolved path in this node and the parent set the text for the parent
Hib,negative, second lock timeout
Hib,negative,property prop new property prop setname id prop setpropertyaccessorname embedded prop setvalue id entity setidentifierproperty prop
Hib,negative,before cascade
Hib,negative,continue we will find out if it ends up not getting saved later
Hib,negative,cascade first so that all unsaved objects get their copy created before we actually copy
Hib,negative,check that entity id requestedid
Hib,negative,not a collection ? return the entity property mapping
Hib,negative,collection of many to any mappings used to circumvent the component collection check below
Hib,negative,otherwise the destination node was implied by the from clause and the from clause processor will automatically add it in the right place
Hib,negative,if the first identifier in the path referrs to the class alias not the class name then this is a correlated subselect if it is a correlated sub select use the existing table alias otherwise generate a new one
Hib,negative,this uses a pathexpressionparser but notice that compound paths are not valid only bare names and simple paths
Hib,negative,origin adddestination destination add the query spaces
Hib,negative,reset the node type because the rest of the system is expecting from fragment all we wanted was for the factory to create the right sub class this might get reset again later on anyway to make the sql generation simpler
Hib,negative,explicit true this is an explict select arraylist sqlresulttypelist new arraylist
Hib,negative,sqlresulttypelist add type generate the select expression
Hib,negative,if the expression list has exactly one expression and the type of the expression is a collection then this might be a collection function such as index c or size c
Hib,negative,the uber rule here is that we need to include subclass joins if the fromelement is in any way dereferenced by a property from the subclass table otherwise we end up with column references qualified by a non existent table reference in the resulting sql
Hib,negative,before cascade
Hib,negative,cascade first so that all unsaved objects get their copy created before we actually copy
Hib,negative,copyvalues works by reflection so explicitly mark the entity instance dirty
Hib,negative,the following variables are stacks that keep information about each subexpression in the list of nested subexpressions we are currently processing
Hib,negative,no need to even collect this information if the persister is considered multi table
Hib,negative,as soon as we encounter our first letter return the substring from that position
Hib,negative,retrieve the value of the designated column in the current row of this resultset object as a java io reader object
Hib,negative,for arrays replaceelements may return a different reference since the array length might not match
Hib,negative,should not be able to reach last without maxposition being set unless there are no results
Hib,negative,do not use proxiesbykey since not all proxies that point to this session is instances are in that collection
Hib,negative,this should be a call to resolve not resolveidentifier  cos it might be a property ref and we did not cache the referenced value
Hib,negative,if we have tt not found ignore tt association mapped to a formula we always need to dirty check it so we can update the second level cache
Hib,negative,we now have the value of the property ref we reference however we need to dig a little deeper as that property might also be an entity type in which case we need to resolve its identitifier
Hib,negative,true if this is a query and we are loading multiple instances of the same collection role otherwise this is a collectioninitializer and we are loading up a single collection or batch
Hib,negative,persister
Hib,negative,this method should be implemented assuming it is valid to do start stop start leave state appropriate for another start
Hib,negative,we do not want to waste effort setting an option if jbc is already in local mode if jbc is repl a sync then check if they passed an config option to disable query replication
Hib,negative,see if we had a nd invalidation from the same initial preinvalidation timestamp if so only increment if the new current value is an increase
Hib,negative,if the workspace node has null as well ok if not we  ve been modified in a non comparable manner which we have to treat as us being newer
Hib,negative,maintain correct duplication if loaded in a cartesian product
Hib,negative,local cache so we use synchronization
Hib,negative,datasource unpooled datasources unpooleddatasource jdbcurl props getproperty environment user props getproperty environment pass
Hib,negative,do not need to lock the cache here since if someone else inserted the same pk first the insert would fail
Hib,negative,we need to grab the version value from the entity otherwise we have issues with generated version entities that may have multiple actions queued during the same flush
Hib,negative,short circuit s no new elements the old list contains only orphans no old elements so no orphans neither
Hib,negative,test out the optimizer
Hib,negative,get the updated snapshot of the entity state by cloning current state it is safe to copy in place since by this time no one else should have has a reference to the array
Hib,negative,persister iscacheinvalidationrequired
Hib,negative,long
Hib,negative,set the existing pool flag to true
Hib,negative,validate that an alias name was provided to determine which pool to use
Hib,negative,we have created the pool ourselves so shut it down
Hib,negative,the load which takes an entity does not pass an entityname
Hib,negative,note expected in the syntax type listenerclass sep type listenerclass where sep is any whitespace or comma
Hib,negative,tree cache in optimistic mode seems to have as very difficult time with remove calls on non existent nodes npes
Hib,negative,we ignore minimalputoverride jbosscache putforexternalread is already about as minimal as we can get it will promptly return if it discovers that the node we want to write to already exists
Hib,negative,it does not refer to an alias of a projection look for a property
Hib,negative,do nothing for persistent instances
Hib,negative,optimisticcache impl
Hib,negative,option setdataversion nonlockingdataversion instance
Hib,negative,assume true since we do not really know and it does not matter
Hib,negative,show the modified ast
Hib,negative,note firstrow is zero based
Hib,negative,initialize dirty flags for arrays collections with composite elements and reset reached doupdate etc
Hib,negative,use the delegate
Hib,negative,use the delegate
Hib,negative,tell the dot node about the join type
Hib,negative,this  dot  expression now refers to the resulting from element
Hib,negative,among other things updatereachables will recursively load all collections that are moving roles this might cause entities to be loaded
Hib,negative,post flushing section
Hib,negative,otherwise recreate the mapping between the collection and its key
Hib,negative,create a parameter specification for the collection filter
Hib,negative,attach any mapping defined order by fragments
Hib,negative,we found some extends attributes referencing entities which were not already processed here we need to locate all entity names and class names contained in this document itself making sure that these get removed from the extendz list such that only extends names which require us to delay processing i e external to this document and not yet processed are contained in the returned result
Hib,negative,make sure that the persister is versioned
Hib,negative,for native sql queries the param metadata is determined outside any relation to a query plan because query plan creation and or retreival for a native sql query depends on all of the return types having been set which might not be the case up front when param metadata would be most useful
Hib,negative,this function has a template redirect output and catch the arguments
Hib,negative,use the id assigned to the instance
Hib,negative,if no array holder we found an unwrappered array this ca not occur because we now always call wrap before getting to here return ah null ? true searchfordirtycollections ah type
Hib,negative,a collection loaded in the current session can not possibly be the collection belonging to the entity passed to update
Hib,negative,if the data type is not an association type it could not have been in the from clause
Hib,negative,we need to generate ids as part of this bulk insert note that this is only supported for sequence style generators and post insert style generators basically only in db generators
Hib,negative,first look for a reference to a projection alias
Hib,negative,first look for a reference to a projection alias
Hib,negative,handle trace logging
Hib,negative,if there are no collection fetches then no further checks are needed
Hib,negative,commented out by inspection am int getwarningcount
Hib,negative,if a threadlocalsessioncontext bound session happens to get serialized to be completely correct we need to make sure that unbinding of that session occurs
Hib,negative,make sure no alias is applied to the table name
Hib,negative,delegate to the queryloader
Hib,negative,switch
Hib,negative,we do not actually propogate antlrexceptions as a cause so log it here for diagnostic purposes
Hib,negative,use the explicitly declared select expression determine the return types indicated by each select token
Hib,negative,select clauses for insert statements should alwasy be treated as shallow
Hib,negative,after that process the joins invoke a delegate to do the work as this is farily complex
Hib,negative,cache impl
Hib,negative,simple cache of param metadata based on query string ideally the original user supplied query string should be used to retreive this metadata i e not the para list expanded query string to avoid unnecessary cache entries used solely for caching param metadata for native sql queries see getsqlparametermetadata for a discussion as to why
Hib,negative,use the delegate
Hib,negative,alias references and identifiers use the same node class
Hib,negative,make a new one
Hib,negative,
Hib,negative,these are just two unrelated table references
Hib,negative,again both should be fromelements
Hib,negative,check a set of parent child nodes in the from clause tree to determine if a comma is required between them
Hib,negative,phase analyze the hql ast and produce an sql ast
Hib,negative,phase generate the sql
Hib,negative,otherwise we have a non scalar select with defined collection fetch es make sure that there is only a single root entity in the return no tuples
Hib,negative,paramtranslations new parametertranslationsimpl collectedparameterspecifications
Hib,negative,we are already processing a dot structure
Hib,negative,should mean that no such property was found
Hib,negative,initialize the error handling delegate
Hib,negative,was there an explicit select expression ?
Hib,negative,resolve everything up to this dot but do not resolve the placeholders yet
Hib,negative,not not between a b between a b
Hib,negative,just add a  not  parent
Hib,negative,first save off the pertinent ids as the return value
Hib,negative,check to see if the connection is in auto commit mode no connection means aggressive connection release outside a jta transaction context so must be autocommit mode
Hib,negative,first save off the pertinent ids saving the number of pertinent ids for return
Hib,negative,start performing the deletes
Hib,negative,do not forget to resolve the argument resolve the collection function now
Hib,negative,otherwise everything ok
Hib,negative,re arrange the tree so that the collection function is the root and the lhs is the path
Hib,negative,protected regionrootlistener listener
Hib,negative,inject the where after the parent
Hib,negative,never include subclasses for implied from elements
Hib,negative,establish the region root node with a non locking data version
Hib,negative,for pessimistic locking we just want to toss out our ref to any old invalid root node and get the latest may be null
Hib,negative,the rest only matters for optimistic locking where we need to establish the proper data version on the region root
Hib,negative,prepare the left hand side and get the data type
Hib,negative,prepare the left hand side and get the data type
Hib,negative,if this dot has already been resolved stop now
Hib,negative,properties
Hib,negative,the property is another class
Hib,negative,otherwise this is a primitive type
Hib,negative,foo bars size also handles deprecated stuff like foo bars maxelement for backwardness
Hib,negative,use the delegate
Hib,negative,for timestamps we default to a separate config
Hib,negative,optimistic lock all include all updatable properties optimistic lock dirty include all properties we are updating this time
Hib,negative,this property belongs to the table and it is not specifically excluded from optimistic locking by optimistic lock false
Hib,negative,information about properties of this class including inherited properties only really needed for updatable insertable properties
Hib,negative,here we render the select column list based on the properties defined as being generated for partial component generation we currently just re select the whole component rather than trying to handle the individual generated portions
Hib,negative,note addduplicatealias already performs nullness checks on the alias
Hib,negative,if the from clauses are the same we can be a little more aggressive in terms of what we reuse
Hib,negative,aload 
Hib,negative,again null null here
Hib,negative,otherwise subquery case dont reuse the fromelement if we are processing the from clause of the subquery
Hib,negative,we know only the lhs hand type so use that
Hib,negative,the referenced node text is the special  id 
Hib,negative,only the identifier property field name can be a reference to the associated entity is pk
Hib,negative,special shortcut for id properties skip the join this must only occur at the end of a path expression
Hib,negative,append the new property name onto the unresolved path
Hib,negative,tell the destination fromelement to  includesubclasses 
Hib,negative,if the lhs is a collection use collectionpropertymapping
Hib,negative,do not resolve the node again
Hib,negative,lists arrays sets maps bags
Hib,negative,we have something like ? op rhs
Hib,negative,configure the cache to use our tm
Hib,negative,make sure jbc does not look one up
Hib,negative,we finish all the removes first to take care of possible unique constraints and so that we can take better advantage of batching
Hib,negative,use a combination of foreign key columns and pk columns since the ordering of removal and addition is not guaranteed when a child moves from one parent to another
Hib,negative,make sure we do not re release the same cache
Hib,negative,we use a different delegate than the non optimistic superclass default
Hib,negative,we have something like lhs op ?
Hib,negative,do not create a unique key  cos some databases do not like a uk on nullable columns getcollectiontable createuniquekey getidentifier getconstraintcolumns
Hib,negative,isset collection isset issorted collection issorted
Hib,negative,we know only the rhs hand type so use that
Hib,negative,if jbc is using invalidation we do not want to propagate changes we use the timestamps cache to manage invalidation
Hib,negative,long
Hib,negative,do not hold the jbc node lock throughout the tx as that prevents updates add a zero or low timeout option so we do not block waiting for tx is that did a put to commit
Hib,negative,double check the distributed cache
Hib,negative,get an exclusive right to update jbc for this key from this node
Hib,negative,one or the other needs to be a datetime for us to get into this method in the first place
Hib,negative, 
Hib,negative,nothing to do
Hib,negative,add the condition to the join sequence that qualifies the indexed element
Hib,negative,sometimes use the element table alias sometimes use the umm collection table alias many to many
Hib,negative,now set the text for this node it should be the element columns
Hib,negative,get the function return value type based on the type of the first argument
Hib,negative,this will call initialize tok
Hib,negative,mutation depends on the types of nodes invloved
Hib,negative,logic operators by definition resolve to booleans
Hib,negative,generated select expressions are already resolved nothing to do
Hib,negative,the path may be a reference to an alias defined in the parent query
Hib,negative,the hql class alias refers to the class name
Hib,negative,associate the table alias with the element
Hib,negative,try the parent fromclause
Hib,negative,make sure that all from elements registered with this from clause are actually in the ast
Hib,negative,invoke setscalarcolumntext on each constructor argument
Hib,negative,collect the select expressions skip the first child because it is the class name
Hib,negative,return an empty type array
Hib,negative,we ensure async semantics jbcache 
Hib,negative,if there is no order by make one
Hib,negative,initial load from jbc
Hib,negative,find the where if there is no where find the from
Hib,negative,now inject the newly built order by into the tree
Hib,negative,logic operators by definition resolve to boolean
Hib,negative,render the identifier select fragment using the table alias
Hib,negative,class names in the from clause result in a joinsequence the old fromparser does this
Hib,negative,will still be issued when it used to be null
Hib,negative,otherwise use the property mapping
Hib,negative,we ensure async semantics jbcache 
Hib,negative,the standard comparator types are not serializable but are singletons
Hib,negative,ignore
Hib,negative,ignore it
Hib,negative,generate implicit joins only if necessary
Hib,negative,if the property is a special collection property name return a collectionpropertymapping
Hib,negative,collection of components
Hib,negative,construct the cache
Hib,negative,local cache so we use synchronization
Hib,negative,ie seconds
Hib,negative,we need to seed the version value as part of this bulk insert
Hib,negative,make sure the lhs is assignable
Hib,negative,false indicates to not generate parens around the assignment
Hib,negative,currently allowed
Hib,negative,in non select queries the only time we should need to join is if we are in a subquery from clause
Hib,negative,return classalias null ? classname classalias
Hib,negative,this is an explicit from element
Hib,negative,swaldman define c p style configuration parameters for initialpoolsize which hibernate sensibly lets default to minpoolsize but we will let users override it with the c p style property if they want
Hib,negative,parametercontainer impl
Hib,negative,fetch ca not be used with scroll or iterate
Hib,negative,if it is not implied or it is implied and it is a many to many join where the target was not found
Hib,negative,we need to wrtap the param in a cast
Hib,negative,since this is an explicit from element it ca not be implied in the from clause
Hib,negative,do nothing eplicit from elements are always in the projection list
Hib,negative,propertyname refers to something like collection size
Hib,negative,property name is a sub path of a component
Hib,negative,always add the collection is query spaces
Hib,negative,nothing to do even if the operand is a parameter no way we could infer an appropriate expected type here
Hib,negative,notify the from element that it is being referenced by the select
Hib,negative,logic operators by definition resolve to booleans
Hib,negative,dotnode uses null here
Hib,negative,we represent a from clause alias
Hib,negative,we are the rhs of the dot representing a naked comp prop ref
Hib,negative,we represent a naked simple prop ref
Hib,negative,early exit return so the resolve call explicitly coming from dotnode can resolve this
Hib,negative,assume this ident is text does not refer to a property on the given persister
Hib,negative,just ignore it for now it will get resolved later
Hib,negative,this is not actually a constant but a reference to from element
Hib,negative,check to see if our proppath actually represents a property on the persister
Hib,negative,these pieces are needed for usage in select clause
Hib,negative,assume we do not refer to a property on the given persister
Hib,negative,true if the pool is borrowed from the outside false if we used to create it
Hib,negative,assume we do not refer to a property on the given persister
Hib,negative,get a connection from the pool thru drivermanager cfr proxool doc
Hib,negative,set the transaction isolation if defined
Hib,negative,naked property refs cannot be used with an aliased from element
Hib,negative,do not over write the column text as that has already been rendered during resolve
Hib,negative,look up class name using the first identifier in the path
Hib,negative,toggle autocommit to false if set
Hib,negative,add to the query spaces
Hib,negative,return the connection
Hib,negative,if the from element is not in the same clause create a new from element
Hib,negative,correlated subqueries create ispecial  implied from nodes because correlated subselects ca not use an ansi style join
Hib,negative,super duper classic parser regression testing mojo magic
Hib,negative,get the configurator files if available
Hib,negative,a collection of entities
Hib,negative,a collection of components
Hib,negative,default the proxool alias setting
Hib,negative,a collection of scalar elements
Hib,negative,validate that an alias name was provided to determine which pool to use
Hib,negative,we only build caches if none were passed in passing in caches counts as a clear statement of exactly what is wanted
Hib,negative,validate that an alias name was provided to determine which pool to use
Hib,negative,do not include sub classes for implied collection joins or subquery joins
Hib,negative,treat explict from elements in sub queries properly
Hib,negative,semantic action handling
Hib,negative,append the stem to the proxool pool alias
Hib,negative,configured using the jaxp configurator
Hib,negative,append the stem to the proxool pool alias
Hib,negative,append the stem to the proxool pool alias
Hib,negative,configured using the properties file configurator
Hib,negative,remember isolation level
Hib,negative,if the provider was leeching off an existing pool do not close it
Hib,negative,note because we  re using astutil createparent the tree must be created from the bottom up is empty x exists query select from from x
Hib,negative,the root from element in correlated subqueries do need this piece
Hib,negative,create the from element for the target the elements of the collection
Hib,negative,if the join is implied then do not include sub classes on the element
Hib,negative,overridden informational metadata
Hib,negative,not really a many to one association necessarily
Hib,negative,the associated entity is implied but it must be included in the from the collection alias is the role
Hib,negative,not really a many to one association necessarily
Hib,negative,always overwrite nonversioned data
Hib,negative,tag this node as a join do not include subclasses in the join this is a clollection join
Hib,negative,public currency getcurrency int col throws hibernateexception
Hib,negative,get the class name of the associated entity
Hib,negative,default is pojo
Hib,negative,use setparameter for null values
Hib,negative,origin path implied columns classalias
Hib,negative,implied
Hib,negative,for implied many to many just add the end join
Hib,negative,interceptor returned null so do the dirtycheck ourself if possible
Hib,negative,use setparameter for null values
Hib,negative,note this
Hib,negative,overridden informational metadata
Hib,negative,overridden informational metadata
Hib,negative,error message constants
Hib,negative,the standard sql function name is current timestamp
Hib,negative,scan for next non whitespace token
Hib,negative,this causes the factory to instantiate the desired class
Hib,negative,private type sqlresulttypes
Hib,negative,private cacheentry cacheentry
Hib,negative,make certain that this is called before any subsequent scheduledupdate aftertransactioncompletion
Hib,negative,typefactory deepcopy currentstate proptypes persister getpropertyupdateability deletedstate session
Hib,negative,frontbase has no known variation of a select for update syntax
Hib,negative,public type getsqlresulttypes return sqlresulttypes
Hib,negative,sqlresulttypelist addall constructorargumenttypelist
Hib,negative,sqlresulttypelist add type
Hib,negative,always add the type to the return type list
Hib,negative,have the entity entry perform post update processing passing it the update state and the new version if one
Hib,negative,this entity defines proeprty generation so process those generated values
Hib,negative,add the fetched entities
Hib,negative,get ready to start adding nodes
Hib,negative,early exit
Hib,negative,oj getjoinable consumescollectionalias
Hib,negative,just especially for the trivial collection filter
Hib,negative,need to look it up from the persistence context
Hib,negative,sort first by role name
Hib,negative,function support
Hib,negative,update last non whitespace token if necessary
Hib,negative,then by fk
Hib,negative,sqlresulttypelist
Hib,negative,nothing to do
Hib,negative,arraylist sqlresulttypelist
Hib,negative,nothing to do
Hib,negative,this method is called when a new non null collection is persisted or when an existing non null collection is moved to a new owner
Hib,negative,notafterclasstokens add
Hib,negative,beforeclasstokens add new definitely do not have this
Hib,negative,lock acquisition support
Hib,negative,todo
Hib,negative,remove initial
Hib,negative,add the type to the list of returned sqlresulttypes
Hib,negative,generate the select expression
Hib,negative,now update all changed or added rows fks
Hib,negative,boolean put persister getcache insert ck cacheentry
Hib,negative,union subclass support
Hib,negative,skip  distinct  and  all  so we return the first expression node
Hib,negative,generate the property select tokens
Hib,negative,get the function name node
Hib,negative,aload 
Hib,negative,this handles hhh where there is a strange property name in a where clause if the lookahead contains a dot then something that is not an ident
Hib,negative,method expressions in a select should always be considered scalar
Hib,negative,areturn return the value of the field
Hib,negative,do nothing we only need to notify the cache
Hib,negative,sort first by entity name
Hib,negative,if this is  elements  then create a new from element
Hib,negative,then by id
Hib,negative,not elements x
Hib,negative,dialect function
Hib,negative,to be safe
Hib,negative,collection  property function 
Hib,negative,if the constant is an ident figure out what it means
Hib,negative,no transformations took place so handle it as we would a non instrumented class
Hib,negative,ident is a class alias in the from
Hib,negative,resolve to an identity column
Hib,negative,see if the entry represents a class file
Hib,negative,otherwise it is a literal
Hib,negative,the name of an entity class
Hib,negative,see if the entry represents a class file
Hib,negative,the class discriminator value
Hib,negative,add a space before the display text
Hib,negative,intentionally empty
Hib,negative,find or create the where clause
Hib,negative,child parent getfirstchild
Hib,negative,set the name of bulk accessor
Hib,negative,aload 
Hib,negative,aload 
Hib,negative,invokespecial
Hib,negative,return
Hib,negative,find or create the where clause
Hib,negative,aload load bean
Hib,negative,filter conditions need to be inserted before the hql where condition and the theta join node this is because org hibernate loader loader binds the filter parameters first then it binds all the hql query parameters see org hibernate loader loader processfilterparameters
Hib,negative,checkcast cast bean
Hib,negative,put the filters node before the hql condition and theta joins
Hib,negative,astore store bean
Hib,negative,add the current fragment to the filters node
Hib,negative,create a new theta joins node as a parent of all filters
Hib,negative,aload args
Hib,negative,put the theta joins node before the hql condition after the filters
Hib,negative,first try to get the persister using the given name directly
Hib,negative,iconst i continue to aastore growing stack is 
Hib,negative,unable to locate it using this name
Hib,negative,if that did not work try using the  import  name
Hib,negative,implicit joins use theta style where pk fk explicit joins use join after from
Hib,negative,locate the registered function by the given name
Hib,negative,determine the type of the first argument
Hib,negative,aload 
Hib,negative,use the dot node to emit the first column name create the column names folled by the column aliases
Hib,negative,append the text of the current node
Hib,negative,if the node has a first child recurse into the first child
Hib,negative,new
Hib,negative,if there is a second child rhs recurse into that child
Hib,negative,dup
Hib,negative,aload load the raw bean
Hib,negative,invokeinterface
Hib,negative,invokevirtual
Hib,negative,invokevirtual
Hib,negative,aastore args
Hib,negative,istore store i
Hib,negative,aload load the bean
Hib,negative,current stack len 
Hib,negative,iterate through the alias joinsequence pairs and generate sql token nodes
Hib,negative,this is used during sqlgenerator processing
Hib,negative,start region to handling exception bulkaccessorexception
Hib,negative,if there is a from fragment and the from element is an explicit then add the from part
Hib,negative,stringhelper isnotempty frag
Hib,negative,iinc 
Hib,negative,the from fragment will probably begin with remove this if it is present
Hib,negative,this uses a pathexpressionparser but notice that compound paths are not valid only bare names and simple paths
Hib,negative,aload load the raw bean
Hib,negative,select p from p in class eg person order by p name p address p
Hib,negative,the reason for this is sql does not let you sort by an expression you are not returning in the result set
Hib,negative,oracle sql state code for deadlock
Hib,negative,aload load the args
Hib,negative,otherwise try to use the no arg constructor
Hib,negative,iconst i
Hib,negative,eat it and try next
Hib,negative,aaload
Hib,negative,checkcast
Hib,negative,default mode
Hib,negative,checkcast case of reference type
Hib,negative,current stack len 
Hib,negative,at some point the processing went bad so we need to make sure the connection handle gets released try to cleanup the jta context as much as possible
Hib,negative,end region to handling exception bulkaccessorexception
Hib,negative,register in exception table
Hib,negative,private constructor stops checkstyle from complaining
Hib,negative,reset the dotcount but not the path after reset
Hib,negative,aload 
Hib,negative,after reset
Hib,negative,following methods we do not delegate since they have so little logic it is clearer to just implement them here
Hib,negative,aload 
Hib,negative,return
Hib,negative,return
Hib,negative,invokevirtual
Hib,negative,checkcast
Hib,negative,dotcount 
Hib,negative,local variables target obj each oldvalue
Hib,negative,astore store exception
Hib,negative,aload load exception
Hib,negative,this bean args raw bean
Hib,negative,iload i
Hib,negative,do the corresponding rhs
Hib,negative,invokespecial bulkaccessorexception init
Hib,negative,athrow
Hib,negative,warning classfile only
Hib,negative,if its id
Hib,negative,swallow
Hib,negative,or its the id property name
Hib,negative,join q createjoinfragment usethetastylejoin
Hib,negative,local variable this
Hib,negative,important
Hib,negative,an association
Hib,negative,aload load this
Hib,negative,allow index function
Hib,negative,aload load this
Hib,negative,aload load callback
Hib,negative,case of non static field
Hib,negative,log a message about potential connection leaks
Hib,negative,getfield get each field
Hib,negative,invokeinterface invoke enabled getinterceptfieldcallback
Hib,negative,ifnonnull
Hib,negative,return each type
Hib,negative,return each type
Hib,negative,store each type
Hib,negative,many to many
Hib,negative,ldc name of the field
Hib,negative,opening paren in new foo
Hib,negative,if we are inside a new result but not inside a nested function
Hib,negative,invokeinterface invoke callback read each type
Hib,negative,special case
Hib,negative,the name of an sql function
Hib,negative,this is basically a copy paste of orderbyparser might be worth refactoring
Hib,negative,select p from p in class eg person group by p name p address p
Hib,negative,return aliases not supported in classic translator
Hib,negative,int
Hib,negative,register collection role
Hib,negative,just do the regular thing if you ca not find the ctor your ast must have default ctor to use this
Hib,negative,return
Hib,negative,the keyword used to specify an identity column if identity column key generation is supported
Hib,negative,getelementpropertymapping
Hib,negative,dup
Hib,negative,following does not handle null not null but unnecessary since this would mean all rows
Hib,negative,checkcast
Hib,negative,checkcast
Hib,negative,crossjoins add name
Hib,negative,ie no select clause in hql
Hib,negative,invokeinterface enabled getinterceptfieldcallback
Hib,negative,invokeinterface enabled getinterceptfieldcallback
Hib,negative,ifnonnull label 
Hib,negative,we are the lhs of the dot representing a naked comp prop ref
Hib,negative,load 
Hib,negative,load 
Hib,negative,ie no select clause
Hib,negative,putfield
Hib,negative,there was a select clause
Hib,negative,return
Hib,negative,ldc field name
Hib,negative,getfield old value of the field
Hib,negative,reference type
Hib,negative,return the concrete type or the underlying type if a concrete type was not specified
Hib,negative,many to many
Hib,negative,reference type
Hib,negative,not array
Hib,negative,array of reference type
Hib,negative,q addcollection collectionname collectionrole
Hib,negative,boolean
Hib,negative,char
Hib,negative,short
Hib,negative,classic parser does not support bulk manipulation statements
Hib,negative,double
Hib,negative,aload 
Hib,negative,float
Hib,negative,float
Hib,negative,this is called when it is time to fully resolve a path expression
Hib,negative,long
Hib,negative,ca not cache this stuff either per invocation
Hib,negative,this is the legacy behaviour for hql queries
Hib,negative,long
Hib,negative,bad type
Hib,negative,bad type
Hib,negative,not known
Hib,negative,boolean byte char int short
Hib,negative,not known
Hib,negative,boolean byte char int short
Hib,negative,not known
Hib,negative,reference type
Hib,negative,not known
Hib,negative,need this since join condition can appear inside parens
Hib,negative,double
Hib,negative,float
Hib,negative,float
Hib,negative,bad type
Hib,negative,bad type
Hib,negative,boolean byte char int short
Hib,negative,expressionopeners add deliberately excluded
Hib,negative,skip finalize methods
Hib,negative,mainly for oscache
Hib,negative,decrement the lock
Hib,negative,recache the updated state
Hib,negative,noop
Hib,negative,null clientlock is remotely possible but will never happen in practice
Hib,negative,by requiring we rely on lock timeout in the case of an unsuccessful update
Hib,negative,the user provided resulttransformer not the one used with select new here to avoid mangling transformed non transformed results
Hib,negative,disassemble positional parameters
Hib,negative,ie seconds
Hib,negative,noop
Hib,negative,otherwise a trim specification and or a trim character have been specified we need to decide which options are present and do the right thing should leading trim characters be trimmed ? should trailing trim characters be trimmed ? the trim character what is to be trimmed off ? the trim source from where should it be trimmed ?
Hib,negative,noop
Hib,negative,noop
Hib,negative,this is called from settingsfactory irregardless trivial to simply disregard
Hib,negative,do nothing subclasses may override
Hib,negative,do nothing subclasses may override
Hib,negative,table
Hib,negative,inside a between and expression
Hib,negative,were an odd or even number of nots encountered the join string built up by compound paths inside this expression a flag indicating if the subexpression is known to be boolean
Hib,negative,ie a many to many
Hib,negative,cope with
Hib,negative,cope with a continued path expression ie baz
Hib,negative,note early return
Hib,negative,cope with a subselect
Hib,negative,use the id value of a newly instantiated instance as the unsaved value
Hib,negative,close extra brackets we opened
Hib,negative,take note when this is a boolean expression
Hib,negative,persister setidentifier result id before calling interceptor for consistency with normal load
Hib,negative,no op ccs did not have such a concept
Hib,negative,joinprocessor needs to know if the where clause fragment came from a dynamic filter or not so it can put the where clause fragment in the right place in the sql ast  hasfiltercondition  keeps track of that fact
Hib,negative,no op ccs did not have such a concept
Hib,negative,assumes that types are all of span 
Hib,negative,again ccs did not have such a concept however a reasonable proximity is to clear the cache for non transaction aware caches we will also do a clear at the end of the transaction
Hib,negative,process a token mapping oo path expressions to sql expressions
Hib,negative,open any extra brackets we might need
Hib,negative,cope with special cases of and not
Hib,negative,the next one up must also be
Hib,negative,add any joins
Hib,negative,named query parameter
Hib,negative,get meta is from hibernate mapping
Hib,negative,get meta is from class
Hib,negative,path expression
Hib,negative,db objectname
Hib,negative,just decrement the lock do not recache we do not know which transaction won
Hib,negative,saves updates do not cascade to uninitialized collections
Hib,negative,mutable
Hib,negative,a container for collections we load up when the owning entity is not yet loaded for now this is purely transient
Hib,negative,where
Hib,negative,check
Hib,negative,polymorphism
Hib,negative,properties that we have tried to load and not found in the database
Hib,negative,todo
Hib,negative,persists do not cascade to uninitialized collections
Hib,negative,anything else
Hib,negative,the path expression continues after a
Hib,negative,careful with this
Hib,negative,the path expression ends at the
Hib,negative,finish off the join
Hib,negative,notice no or since they are part of compound identifiers
Hib,negative,cannot instantiate
Hib,negative,start by looking for hql keywords
Hib,negative,inner joins can be abbreviated to  join 
Hib,negative, outer  is optional and is ignored
Hib,negative,now anything that is not a hql keyword
Hib,negative,process the old hql style where aliases appear first ie using the in or in class constructions
Hib,negative,treat it as a classname
Hib,negative,treat it as a path expression
Hib,negative,starts with a path expression new style
Hib,negative,id
Hib,negative,allow odmg oql style from person p p cars c
Hib,negative,handle quoted strings
Hib,negative,version timestamp
Hib,negative,discriminator
Hib,negative,primary key constraint
Hib,negative,this is either a version tag with no type attribute or a timestamp tag
Hib,negative,object insertions updates and deletions have list semantics because they must happen in the right order so as to respect referential integrity
Hib,negative,finish off the join
Hib,negative,ignore whitespace
Hib,negative,do replacements
Hib,negative,handle hql collection syntax
Hib,negative,uuid hex is deprecated
Hib,negative,abstractselectingdelegate impl
Hib,negative,hilo params
Hib,negative,sql query
Hib,negative,for ejb 
Hib,negative,performance opt
Hib,negative,sql update
Hib,negative,discriminator
Hib,negative,hilo config
Hib,negative,so we clock over on the first invocation
Hib,negative,do not allow comments on these insert statements as comments totally blow up the oracle getgeneratedkeys support
Hib,negative,throw new identifiergenerationexception save associated object first or disable cascade for inverse association
Hib,negative,count
Hib,negative,go ahead and set the lazy here since pojo proxy can override it
Hib,negative,dynamic update
Hib,negative,import
Hib,negative,batch size
Hib,negative,we need to dirty check collections since they can cause an owner version number increment
Hib,negative,select before update
Hib,negative,optimistic lock mode
Hib,negative,intentionally empty
Hib,negative,first element of array is reserved for the actual instance we are loading
Hib,negative,keep the behavior consistent even for boundary usages
Hib,negative,so we clock over on the first invocation
Hib,negative,do nothing until we hit the rsult set containing the generated id
Hib,negative,use the delegate resolve identifiers as from element aliases
Hib,negative,persister
Hib,negative,custom sql
Hib,negative,loaded entity instances by entitykey
Hib,negative,if the given name is un qualified we may neen to qualify it
Hib,negative,the default
Hib,negative,cascade save to many to one before the parent is saved
Hib,negative,get meta is from subclass
Hib,negative,properties
Hib,negative,joined subclasses
Hib,negative,key
Hib,negative,check
Hib,negative,properties
Hib,negative,intentionally empty
Hib,negative,key
Hib,negative,even process null collections
Hib,negative,keep the existing version number in the case of replicate
Hib,negative,source getpersistencecontext removenonexist new entitykey id persister source getentitymode
Hib,negative,substitutes into values by side effect
Hib,negative,identity map of collectionentry instances by the collection wrapper
Hib,negative,tablename
Hib,negative,table specific parameters
Hib,negative,join getkey settype new type lazz getidentifier
Hib,negative,source getbatcher executebatch found another way to ensure that all batched joined inserts have been executed
Hib,negative,identifiergenerator implementation
Hib,negative,properties
Hib,negative,persistentidentifiergenerator implementation
Hib,negative,prepare and execute the insert
Hib,negative,column s
Hib,negative,if everything went ok commit the transaction and close the obtained connection handle
Hib,negative,prepare and execute the insert
Hib,negative,fetch the generated id in a separate query
Hib,negative,we just hit the last position
Hib,negative,scroll ahead
Hib,negative,scroll backward
Hib,negative,column index
Hib,negative,we have not yet hit the last result
Hib,negative,state
Hib,negative,criteria impl
Hib,negative,column unique key
Hib,negative,do this when all the properties are updateable since there is a certain likelihood that the information will already be snapshot cached
Hib,negative,state
Hib,negative,criteria impl
Hib,negative,caches
Hib,negative,generators
Hib,negative,cache region is defined by the root class in the hierarchy
Hib,negative,properties
Hib,negative,jndi serialization
Hib,negative,checking for named queries
Hib,negative,stats
Hib,negative,entitynotfounddelegate
Hib,negative,check named hql queries
Hib,negative,this will throw an error if there is something wrong
Hib,negative,prevents this session from adding things to cache
Hib,negative,look for the instance by uuid
Hib,negative,for a dynamic class
Hib,negative,test this entity to see if we must query it
Hib,negative,note early exit
Hib,negative,for backward compatability
Hib,negative,ignore this error for now
Hib,negative,must add to jndi after adding to hashmaps because some jndi servers use serialization
Hib,negative,look for existing collection as part of the persistence context
Hib,negative,make sure this is a defined parameter and check the incoming value type
Hib,negative,for each of the defined parameters make sure its value has been set
Hib,negative,we never need to apply locks to the sql
Hib,negative,deletes
Hib,negative,updates
Hib,negative,cache the actual id of the object not the value of the property ref which might not be initialized
Hib,negative,loading
Hib,negative,select range is terminated by declaration of from
Hib,negative,for an any
Hib,negative,insertable simply because that is the user did not specify anything just override it
Hib,negative,properties generated on update can never be updateable
Hib,negative,updateable only because the user did not specify anything just override it
Hib,negative,the user specifically supplied update true which constitutes an illegal combo
Hib,negative,rolename
Hib,negative,final boolean forcecacherefresh
Hib,negative,first try to load it from the temp pc associated to this ss
Hib,negative,otherwise immediately materialize it
Hib,negative,
Hib,negative,no auto flushing to support in stateless session
Hib,negative,fetch strategy
Hib,negative,table
Hib,negative,after setting values to object entitymode
Hib,negative,sort
Hib,negative,do a check
Hib,negative,saveorupdate operations
Hib,negative,update operations
Hib,negative,lock operations
Hib,negative,persist operations
Hib,negative,persistonflush operations
Hib,negative,delete operations
Hib,negative,load get operations
Hib,negative,refresh operations
Hib,negative,custom sql
Hib,negative,unsorted natural comparator class name
Hib,negative,replicate operations
Hib,negative,set up second pass
Hib,negative,do not auto flush while outside a transaction
Hib,negative,this is an internal error of some sort
Hib,negative,do not return a proxy this option indicates we are initializing a proxy
Hib,negative,ignore
Hib,negative,for an any we will have to use reflection
Hib,negative,only collections belonging to deleted entities are allowed to be dereferenced in the case of orphan delete
Hib,negative,if it was previously unreferenced we need to flush in order to get its state into the database in order to execute query
Hib,negative,not for internal use
Hib,negative,otherwise we only need to flush if there are in memory changes to the queried tables
Hib,negative,aload 
Hib,negative,if it is initialized see if the underlying instance is contained since we need to account for the fact that it might have been evicted
Hib,negative,stops flush being called multiple times if this method is recursively called
Hib,negative,decode row selection
Hib,negative,basically just an adapted copy of find criteriaimpl
Hib,negative,ignore this error for now
Hib,negative,we need to writeobject on this since interceptor is user defined
Hib,negative,the old time stand by
Hib,negative,parameter bind values
Hib,negative,parameter handling code
Hib,negative,execution methods
Hib,negative,note special case one to one constrained false cannot be proxied so default to join and non lazy
Hib,negative,use old hb defaults if outer join is specified
Hib,negative,we have a cglib enhanced entity
Hib,negative,we have a cglib enhanced entity
Hib,negative,we have a javassist enhanced entity
Hib,negative,we have a javassist enhanced entity
Hib,negative,fieldinterceptor impl
Hib,negative,subclass accesses
Hib,negative,fieldhandler impl
Hib,negative,should not need to grow beyond the size of the total number of columns in the rs
Hib,negative,should probably no op commit rollback here at least in jta scenarios
Hib,negative,various expectation instances
Hib,negative,explicitly perform no checking
Hib,negative,used from testsuite
Hib,negative,assume we are in an auto commit state
Hib,negative,package
Hib,negative,generator
Hib,negative,register synch stats connect
Hib,negative,calls executebatch
Hib,negative,no big deal
Hib,negative,no big deal
Hib,negative,no big deal
Hib,negative,see explanation above
Hib,negative,if we are in the process of releasing no sense checking for aggressive release possibility
Hib,negative,early exit
Hib,negative,resultset impl overridden
Hib,negative,resultset impl delegated
Hib,negative,id unsaved value
Hib,negative,version unsaved value
Hib,negative,not necessarily a unique property reference
Hib,negative,bind the where
Hib,negative,refer to comment in statefulpersistencecontext addcollection
Hib,negative,connectionmanager callback implementation
Hib,negative,note success false because we do not know the outcome of the transaction
Hib,negative,bind the order by
Hib,negative,we already have a callback registered either a local org hibernate transaction transaction has accepted callback responsibilities or we have previously registered a transaction synch
Hib,negative,bind the filters
Hib,negative,overriding inherited meta attribute hbx hbx 
Hib,negative,first iterate over all elements capable of defining an extends attribute collecting all found extends references if they cannot be resolved against the already processed mappings
Hib,negative,referencedcolumnname not used for backward compatibility
Hib,negative,sessionfactory name
Hib,negative,jdbc and connection settings
Hib,negative,jdbc and connection settings
Hib,negative,interrogate jdbc metadata
Hib,negative,user supplied jdbc connections
Hib,negative,transaction settings
Hib,negative,sql generation settings
Hib,negative,query parser settings
Hib,negative,second level query cache
Hib,negative,sql exception converter
Hib,negative,statistics and logging
Hib,negative,settings setshowsqlenabled showsql
Hib,negative,postinitialize will be called after initialization
Hib,negative,settings setformatsqlenabled formatsql
Hib,negative,cannot handle single quotes
Hib,negative,schema export
Hib,negative,todo for private static final logger log loggerfactory getlogger sqlstatementlogger class this is the legacy logging  category 
Hib,negative,if dotted and not load collection nor return join regular property
Hib,negative,do not even bother trying to read further
Hib,negative,private componenttuplizerfactory componenttuplizerfactory todo hhh and hhh private bytecodeprovider bytecodeprovider
Hib,negative,public getters
Hib,negative,generated properties can never be insertable
Hib,negative,public componenttuplizerfactory getcomponenttuplizerfactory return componenttuplizerfactory
Hib,negative,package protected setters
Hib,negative,public bytecodeprovider getbytecodeprovider return bytecodeprovider void setbytecodeprovider bytecodeprovider bytecodeprovider this bytecodeprovider bytecodeprovider
Hib,negative,using local since the inheritedmetas at this point is not the correct map since it is always the empty map
Hib,negative,protected list extendsqueue
Hib,negative,extendsqueue new arraylist
Hib,negative,componenttuplizerfactory new componenttuplizerfactory
Hib,negative,if doc is null then for whatever reason the cached file cannot be used
Hib,negative,position cursor to the last row
Hib,negative,sequentially read the result set in reverse until we recognize a change in the key value at that point we are pointed at the last physical sequential row for the logical row in which we are interested in processing
Hib,negative,read backwards until we read past the first physical sequential row with the key we are interested in loading
Hib,negative,finally read ahead one row to position result set cursor at the first physical row we are interested in loading
Hib,negative,this method may be called many times
Hib,negative,force the proxy to resolve itself
Hib,negative,this is equivalent to the old behavior
Hib,negative,if null owner will be retrieved from session
Hib,negative,iterator iterator extendsqueue iterator
Hib,negative,iterator iter extendsqueue iterator
Hib,negative,found
Hib,negative,found
Hib,negative,settings setcomponenttuplizerfactory this getcomponenttuplizerfactory
Hib,negative,final string querystring
Hib,negative,private final list extendsqueue
Hib,negative,string string
Hib,negative,string string
Hib,negative,invokeinterface
Hib,negative,end of array start filling again from start
Hib,negative,set use reflection optimizer to false to fix hhh 
Hib,negative,orphan delete not supported for entitymode dom j
Hib,negative,element xmlhelper generatedom jelement persister getnodename
Hib,negative,intentionally empty
Hib,negative,we can reuse it for each row
Hib,negative,orphan delete not supported for entitymode dom j
Hib,negative,ca not reuse in this case
Hib,negative,element xmlhelper generatedom jelement persister getnodename
Hib,negative,needed for soap libraries etc
Hib,negative,early exit
Hib,negative,any earlier proxy takes precedence
Hib,negative,first we need to suspend any current jta transaction and obtain a jdbc connection
Hib,negative,getresultlist results
Hib,negative,if we only returned one entity query by key is more efficient
Hib,negative,the element has been removed from the set
Hib,negative,the element has changed
Hib,negative,handle trace logging
Hib,negative,careful these methods do not initialize the collection
Hib,negative,needed so that we remove this collection from the second level cache
Hib,negative,override on some subclasses
Hib,negative,override on some subclasses
Hib,negative,do this bit after setting initialized to true or it will recurse
Hib,negative,create the collection holding the orphans
Hib,negative,collect entityidentifier s of the current elements add them into a hashset for fast access
Hib,negative,iterate over the old list
Hib,negative,intentionally empty
Hib,negative,array null ? templist get i
Hib,negative,a many to many decrement currentdepth here to allow join across the association table without exceeding max fetch depth i e the currentdepth bit
Hib,negative,write does not
Hib,negative,write does not
Hib,negative,this is the regression style determination which matches the logic of the classic translator
Hib,negative,a collection loaded in the current session can not possibly be the collection belonging to the entity passed to update
Hib,negative,handle empty collection
Hib,negative,handle empty collections
Hib,negative,else this is not a collection initializer and empty collections will be detected by looking for the owner is identifier in the result set
Hib,negative,needed for soap libraries etc
Hib,negative,finally what it is all about
Hib,negative,here we do not bother with the discriminator
Hib,negative,validate instances of validatable
Hib,negative,null version means the object is in the process of being loaded somewhere else in the resultset
Hib,negative,problematic for key many to one
Hib,negative,use the id passed in
Hib,negative,the property is a collection
Hib,negative,anyway here we implement set semantics for a one to many bag
Hib,negative,a shortcut if its location did not change
Hib,negative,search for it note that this code is incorrect for other than one to many
Hib,negative,a composite key
Hib,negative,if no batch use foo ? and bar ?
Hib,negative,it must be a collection fetch
Hib,negative,needed later for many to many filter application
Hib,negative,etype isreferencetoprimarykey
Hib,negative,collection wrappers by the collectionkey key collectionkey value persistentcollection
Hib,negative,it might still need to apply a collection ordering based on a many to many defined order by
Hib,negative,belong to other persister belong to other persister
Hib,negative,we found it
Hib,negative,we can use an inner join for the many to many
Hib,negative,disable a join back to this same association
Hib,negative,note unlike all other loaders this one is not multithreaded or cacheable
Hib,negative,the user visible aliases which are unknown to the superclass these are not the actual physical sql aliases
Hib,negative,let return propertys override whatever the persister has for aliases
Hib,negative,alias may be null early exit
Hib,negative,if it is a compound path
Hib,negative,if its the root criteria we are done
Hib,negative,otherwise recurse
Hib,negative,the criteria instance
Hib,negative,the entity name
Hib,negative,not found in inner query try the outer query
Hib,negative,not found in inner query try the outer query
Hib,negative,it refers to an alias of a projection
Hib,negative,should never happen i think
Hib,negative,convert the string value into the proper type
Hib,negative,needed for soap libraries etc
Hib,negative,and the qualifier is not the alias of this criteria check to see if we belong to some criteria other than the one that created us
Hib,negative,it does not refer to an alias of a projection look for a property
Hib,negative,search for it note that this code is incorrect for other than one to many
Hib,negative,otherwise this is an ordinary value
Hib,negative,currently not cachable if autodiscover types is in effect e g select
Hib,negative,list operations
Hib,negative,private final string sqlaliases private final string sqlaliassuffixes
Hib,negative,this is only needed afaict for resulttransformer processing
Hib,negative,determine if the collection elements are entities
Hib,negative,replace with corresponding column aliases
Hib,negative,no additional open braces found in the string append the rest of the string in its entirty and quit this loop
Hib,negative,apend everything up until the next encountered open brace
Hib,negative,pad with nulls from the current last element up to the new index
Hib,negative,it is a simple table alias foo
Hib,negative,passing through anything we do not know to support jdbc escape sequences hb 
Hib,negative,passing through anything we do not know to support jdbc escape sequences hb 
Hib,negative,the current alias is referencing the collection to be eagerly fetched
Hib,negative,it is a property reference foo bar
Hib,negative,package
Hib,negative,note early exit
Hib,negative,private final list scalartypes new arraylist private final list scalarcolumnaliases new arraylist
Hib,negative,now process the returns
Hib,negative,already been processed
Hib,negative,already been processed
Hib,negative,make sure the owner alias is known
Hib,negative,scalarcolumnaliases add typereturn getcolumnalias scalartypes add typereturn gettype
Hib,negative,if this return is alias has not been processed yet do so b further processing of this return
Hib,negative,collectionowneraliases add owneralias
Hib,negative,needed for soap libraries etc
Hib,negative,needed for soap libraries etc
Hib,negative,from map
Hib,negative,from sortedmap
Hib,negative,cannot be instantiated
Hib,negative,inject the data
Hib,negative,default pool size 
Hib,negative,if debug level is enabled then log the password otherwise mask it
Hib,negative,register a cleanup synch
Hib,negative,wrap the session in the transaction protection proxy
Hib,negative,then bind it
Hib,negative,this property belongs on the table and is to be inserted
Hib,negative,limit the methods available if no transaction is active
Hib,negative,allow these deprecated methods to pass through
Hib,negative,serialization
Hib,negative,add temp entry so that the next step is circular reference safe only needed because some types do not take proper advantage of two phase load esp components
Hib,negative,this is the second pass through on a merge op so here we limit the replacement to associations types value types were already replaced during the first pass
Hib,negative,early exit
Hib,negative,handle collection fiter compilation important note this is modifying the input hql tree not the output tree
Hib,negative,initialize the error handling delegate
Hib,negative,cannot be instantiated
Hib,negative,private string propertyname
Hib,negative,use the delegate
Hib,negative,string fk stringhelper qualify collection cp getkeycolumnnames
Hib,negative,collection where
Hib,negative,unsupported
Hib,negative,unsupported
Hib,negative,if not a composite key use foo in ? ? ? for batching if no batch and not a composite key use foo ?
Hib,negative,currently only the hibernate supplied dbtimestamptype is supported here
Hib,negative,cannot be instantiated
Hib,negative,this is called when it is time to fully resolve a path expression
Hib,negative,implicit polymorphism not supported would need a union
Hib,negative,pull off the last
Hib,negative,non nls 
Hib,negative,always do an insert and let it fail by constraint violation
Hib,negative,by default natural ids are immutable constant
Hib,negative,we have the form trim from trimsource this is functionally equivalent to trim trimsource
Hib,negative,not supported should use jdbc preparedstatement getgeneratedkeys method
Hib,negative,make a new one
Hib,negative,astore store the raw bean
Hib,negative,overridden informational metadata
Hib,negative,not so sure this is even valid subtree but if it was it  d represent two unrelated table references
Hib,negative,note firstrow is zero based
Hib,negative,grrr for differentiation of mysql storage engines
Hib,negative,current stack len 
Hib,negative,string keycols collpersister getkeycolumnnames
Hib,negative,oracle did add support for ansi case statements in i
Hib,negative,the standard sql function name is current timestamp
Hib,negative,refresh does not pass an entityname
Hib,negative,informix does not have a bit type
Hib,negative,not gt a b le a b
Hib,negative,strip table owner because informix always returns constraint names as table owner constraint name
Hib,negative,build the map of standard ansi sql aggregation functions
Hib,negative,pre h behavior super getreturntype ct m
Hib,negative,finally use the sqltype if on hibernate types did not find a match
Hib,negative,because numeric can be anything
Hib,negative,constructors and factory methods
Hib,negative,standard sql functions can be overridden by subclasses
Hib,negative,map second minute hour day month year to ansi extract override on subclasses
Hib,negative,database type mapping support
Hib,negative,hibernate type mapping support
Hib,negative,private type sqlresulttypes
Hib,negative,native identifier generatiion
Hib,negative,identity support
Hib,negative,sequence support
Hib,negative,limit offset support
Hib,negative,by default we report no support
Hib,negative,sqlresulttypes selectclause getsqlresulttypes
Hib,negative,by default we report no support for nowait lock semantics
Hib,negative,temporary table support
Hib,negative,callable statement support
Hib,negative,current timestamp support
Hib,negative,miscellaneous support
Hib,negative,identifier quoting support
Hib,negative,by default
Hib,negative,this is now handled earlier in this method
Hib,negative,loader implementation
Hib,negative,loader overrides
Hib,negative,not is null a b is not null a b
Hib,negative,here assume sqlserver using snapshot isolation which does not have this problem
Hib,negative,none because its the requested lock mode not the actual
Hib,negative,query translator methods
Hib,negative,oracle and previous define only a date type which is used to represent all aspects of date time
Hib,negative,starts with implicitly
Hib,negative,cascade
Hib,negative,implementation private methods
Hib,negative,trim off the length precision scale
Hib,negative,check violation
Hib,negative,unique violation
Hib,negative,foreign key violation
Hib,negative,deduplicate unique constraints sharing the same columns this is needed by hibernate annotations since it creates automagically unique constraints for the user
Hib,negative,overridden informational metadata
Hib,negative,to support dialects that have their own identity data type
Hib,negative,not null violation
Hib,negative,all other
Hib,negative,register the type of the out param postgresql uses types other
Hib,negative,seems to have spotty lob suppport
Hib,negative,hhh 
Hib,negative,ignore probably h not in the classpath
Hib,negative,prepare the left hand side and get the data type
Hib,negative,numeric functions
Hib,negative,used also for generation of fk names
Hib,negative,usually useless
Hib,negative,do not add unique constraint on db not supporting unique and nullable columns
Hib,negative,for backward compatibility disable this
Hib,negative,may be final may be final may be final
Hib,negative,may be final
Hib,negative,may be final
Hib,negative,custom sql
Hib,negative,primary key constraint
Hib,negative,ignore it
Hib,negative,time and date functions
Hib,negative,system functions
Hib,negative,not null is implicit
Hib,negative,display the dialect version
Hib,negative,nothing to do in a stateful session
Hib,negative,the rdms concat function only supports parameters
Hib,negative,flat recursive algorithm
Hib,negative,an identifier mapper getkey will be included in the getnonduplicatedpropertyiterator and checked later so it needs to be excluded
Hib,negative,current stack len 
Hib,negative,dialect method overrides
Hib,negative,custom sql
Hib,negative,primary key constraint
Hib,negative,original dialect java returns for update
Hib,negative,pass the column name a generated id almost always has a single column
Hib,negative,needed to satisfy keyvalue
Hib,negative,verify the state of this new method in hibernate dialect java
Hib,negative,origial dialect java returns true
Hib,negative,index should be last column listed
Hib,negative,sequence methods start the rdms dialect needs these
Hib,negative,methods to make it possible to use the native id generator
Hib,negative,if it is a formula index use the element columns in the pk
Hib,negative,do not create a unique key  cos some databases do not like a uk on nullable columns
Hib,negative,sequence methods end
Hib,negative,
Hib,negative,starts with implicitly
Hib,negative,used with drop table to delete all records in the table
Hib,negative,no foreign key element of for a one to many
Hib,negative,todo we could just return all false
Hib,negative,the case of a foreign key to something other than the pk is handled in createpropertyrefconstraints
Hib,negative,the object is persistent
Hib,negative,rdms supports the union all clause
Hib,negative,multi param dialect functions
Hib,negative,function templates
Hib,negative,todo we could just return all false
Hib,negative,not null is implicit
Hib,negative,this assumes schema support which is present in and later
Hib,negative,columnupdateability length 
Hib,negative,hsqldb only supports read uncommitted transaction isolation
Hib,negative,the entity is associated with the session so check its status
Hib,negative,multi param string dialect functions
Hib,negative,multi param numeric dialect functions
Hib,negative,multi param date dialect functions
Hib,negative,simple nullability constraint
Hib,negative,overridden informational metadata
Hib,negative,overridden informational metadata
Hib,negative,return
Hib,negative,register the type of the out param an oracle specific type
Hib,negative,timesten has no blob clob support but these types may be suitable for some applications the length is limited to million bytes
Hib,negative,new methods in dialect 
Hib,negative,public boolean supportsforupdatenowait return false
Hib,negative,timesten has no known variation of a select for update syntax
Hib,negative,iterate entries ordered by capacity to find first fit
Hib,negative,add new ordered map
Hib,negative,expected type is intrinsic here
Hib,negative,overridden informational metadata
Hib,negative,
Hib,negative,
Hib,negative,return memberpersister getpropertytype propertyname
Hib,negative,return memberpersister tocolumns alias propertyname
Hib,negative,return memberpersister gettype
Hib,negative,indexisformula
Hib,negative,return isonetomany
Hib,negative,instanceof associationtype
Hib,negative,we need to determine the best way to know that two joinables represent a single many to many
Hib,negative,strip leading    
Hib,negative,public boolean issubselectloadable
Hib,negative,columns
Hib,negative,sql statements
Hib,negative,extra information about the element type
Hib,negative,types
Hib,negative,sql server just returns automatically
Hib,negative,custom sql
Hib,negative,private final string unquotedidentifiercolumnname
Hib,negative,return select current timestamp from rdb database
Hib,negative,dynamic filters specifically for many to many inside the collection
Hib,negative,dynamic filters for the collection
Hib,negative,registercolumntype data types
Hib,negative,ibid for current time and current date
Hib,negative,if we  ve been blocking for the mutex perhaps another thread has already reestablished the root in case the node was reestablised via replication confirm it is marked resident a status which does not replicate
Hib,negative,tell hibernate to use getbytes instead of getbinarystream
Hib,negative,no batch statements
Hib,negative,element
Hib,negative,we might want a special case for this is very common for money types and here it is converted to 
Hib,negative,no pointbase bit
Hib,negative,no pointbase tinyint
Hib,negative,nativesql collect element column and auto aliases
Hib,negative,index and row select
Hib,negative,starts with implicitly
Hib,negative,sql server at least up through does not support defining cascade delete constraints which can circel back to the mutating table
Hib,negative,nativesql collect index column and auto aliases
Hib,negative,here assume sqlserver using snapshot isolation which does not have this problem
Hib,negative,registercolumntype types clob mediumtext registercolumntype types clob text
Hib,negative,registercolumntype types varchar mediumtext registercolumntype types varchar text
Hib,negative,starts with implicitly
Hib,negative,generate the sql
Hib,negative,package private
Hib,negative,not all classpersisters implement propertymapping
Hib,negative,handle any filters applied to this collection for many to many
Hib,negative,if there is a user specified loader return that todo filters ?
Hib,negative,take care of any entities that might have been evicted
Hib,negative,strip leading    
Hib,negative,run a subquery loader
Hib,negative,we ca not change the tm on a running cache just check if the cache has no tm and we  re ok with that
Hib,negative,sybase bit type does not support null values
Hib,negative,we could register the session against the transaction even though it is not started but we  d have no guarentee of ever getting the map entries cleaned up aside from spawning threads
Hib,negative,needed by arrays
Hib,negative,ignore
Hib,negative,this assumes you will want to ignore any update counts
Hib,negative,todo something with formulas
Hib,negative,an assertion
Hib,negative,remove all the old entries
Hib,negative,local variables target obj each oldvalue
Hib,negative,create all the new entries
Hib,negative,indexisformula
Hib,negative,indexisformula
Hib,negative,delete all the deleted entries
Hib,negative,insert all the new entries
